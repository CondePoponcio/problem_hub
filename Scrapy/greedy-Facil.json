[
{"titulo": "DivideLoot", "categoria": "[\"Greedy\", \"SimpleMath\", \"SimpleSearch\", \"Iteration\", \"Sorting\"]", "dificultad": "Facil", "enunciado": " N pirates have stolen a treasure chest. The treasure chest contains some loot. The prices of the individual items in the chest are given in the int[] loot. There are at least N, but less than 2N items in the chest.   The pirates want to divide the loot according to the following rules:    Return \"possible\" if the pirates can divide the loot according to the above rules, or \"impossible\" if they cannot do that. ", "pruebas": "[[\"1\", \"{47}\", \"Returns: \\\"possible\\\"\"], [\"3\", \"{10, 8, 10, 1, 1}\", \"Returns: \\\"impossible\\\"\"], [\"3\", \"{3, 9, 10, 7, 1}\", \"Returns: \\\"possible\\\"\"], [\"6\", \"{1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1}\", \"Returns: \\\"possible\\\"\"], [\"2\", \"{40, 1, 42}\", \"Returns: \\\"impossible\\\"\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=16672"},
{"titulo": "ChristmasCrackerHappiness", "categoria": "[\"Greedy\", \"SimpleMath\", \"Simulation\"]", "dificultad": "Facil", "enunciado": " A Christmas cracker is a festive table decoration that resembles an oversized sweet-wrapper. The middle part of a cracker usually contains some small gift and a terrible Christmas pun. (\"What does Santa feel when going down a narrow chimney? Claus-trophobia!\")    It is customary that each cracker should be opened by two people. Each person takes hold of one end of the cracker and they pull in opposite directions. This will cause the cracker to split into two parts. The cracker always splits unevenly: one of the two people is the winner and gets the central chamber with the prize, the other person is the loser and gets nothing.   Whenever a cracker is opened, the winner is determined randomly. The two people opening the cracker cannot influence which one of them will be the winner.    N guests (numbered 0 to N-1) are attending your Christmas party. You already gave them M crackers (numbered 0 to M-1), and they have already opened all of them. For cracker i, guest number winner[i] was the winner and got the prize, while guest number loser[i] was the loser and got nothing.    A guest is happy if they were the winner at least once.   You would like all guests at your party to be happy. Sadly, that is not always possible: somebody may be really unlucky and lose each time they open a cracker. Thus, you would like the next best thing: at least N-1 of your guests should be happy.   You are now going to buy some additional crackers. You will then give the crackers to your guests to open. You will be handing the crackers out one at a time. For each cracker, you can select the two guests who should open it. You can then wait and see who won before you hand out the next cracker.   Remember that your goal is that at least N-1 of your guests should be happy. What is the minimum number of crackers you need to purchase so that you can reach your goal with absolute certainty? Calculate and return that number. ", "pruebas": "[[\"2\", \"{}\", \"{}\", \"Returns: 1\"], [\"5\", \"{0, 1, 0, 3, 2, 0, 4, 0}\", \"{3, 3, 4, 1, 0, 2, 1, 3}\", \"Returns: 0\"], [\"12\", \"{3, 1, 4, 1, 5, 9, 2, 6}\", \"{5, 3, 5, 8, 9, 7, 9, 3}\", \"Returns: 4\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=16716"},
{"titulo": "BuyOneGetOneFree", "categoria": "[\"BruteForce\", \"Greedy\", \"Sorting\"]", "dificultad": "Facil", "enunciado": " There are some items you want to purchase from a store. The prices of these items are given in the int[] prices.   You can purchase any item by paying its price.   However, the store also has a special sale today: \" one, get one free\". This means that whenever you bring a pair of items to the cash register, you only have to pay for the more expensive one and you'll get the other one for free as a bonus.   Given the prices, find the optimal shopping strategy and calculate the minimum you have to pay to purchase all the items you want. ", "pruebas": "[[\"{47}\", \"Returns: 47\"], [\"{10, 20}\", \"Returns: 20\"], [\"{10, 20, 30, 20}\", \"Returns: 50\"], [\"{5, 7, 13, 2, 9}\", \"Returns: 22\"], [\"{100, 100, 100, 100, 100, 100}\", \"Returns: 300\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=16754"},
{"titulo": "NBAFinals", "categoria": "[\"Greedy\", \"SimpleMath\"]", "dificultad": "Facil", "enunciado": " In the finals of the NBA 2019 playoffs the (Golden State) Warriors are playing the (Toronto) Raptors.   A transcript of a game is a sequence of integers and a string of characters. The transcript is obtained as follows:  Whenever a team's possession of the ball ends in the team scoring some points, we append the number of points scored to the sequence of integers and we append a character representing the team ('W' for the Warriors, 'R' for the Raptors) to the string of characters.   Note that on each possession a team can score at most four points. (The four-point play occurs when a player scores a field goal and then gets awarded free throw(s) for being fouled while making the shot.)   For example, the sequence {2, 4, 1} and the string \"RWW\" represent a game in which first the Raptors scored 2 points, then the Warriors scored 4 points, and then the Warriors scored another 1 point.   Teja is rooting for the Warriors. However, he was busy preparing problems for this SRM and he missed one of the games. He only has a transcript of the game: the int[] scores and the String team.   The transcript of the game is damaged: some values in scores and some (not necessarily the same) characters in team have been erased. In scores the erased values are represented by zeros and in team the erased characters are represented by question marks.   Help Teja determine whether the Warriors could have won the game at the end of the transcript. Return 1 if it is possible and 0 if it isn't. ", "pruebas": "[[\"{2, 2, 3, 3, 2, 4, 2}\", \"\\\"RRWWRWR\\\"\", \"Returns: 1\"], [\"{2, 2, 3, 3, 2, 3, 3}\", \"\\\"RRWWRWR\\\"\", \"Returns: 0\"], [\"{0, 3}\", \"\\\"WR\\\"\", \"Returns: 1\"], [\"{3, 0, 0}\", \"\\\"RWR\\\"\", \"Returns: 0\"], [\"{0, 0, 0, 0}\", \"\\\"????\\\"\", \"Returns: 1\"], [\"{3, 2, 3, 2}\", \"\\\"?WR?\\\"\", \"Returns: 1\"], [\"{0, 1, 2, 3, 4}\", \"\\\"R?W?R\\\"\", \"Returns: 1\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15528"},
{"titulo": "PartitionArray", "categoria": "[\"Greedy\"]", "dificultad": "Facil", "enunciado": " An array A is called positive partitionable if we can divide A into one or more contiguous subarrays such that each element belongs to exactly one of the subarrays and the sum of each subarray is positive.   For example, the array {3,-7,8} is positive partitionable. One valid way of splitting this array is to split it into {3} and {-7,8}. The array {0,1,0,1,2} is also positive partitionable. The array {-1,2,-3,4,-5} and the array {0} are not positively partitionable.   A partition of an array can be described by listing the lengths of the partitions, in order. For example, {3} has length 1 and {-7,8} has length 2, hence the partition of {3,-7,8} into {3} and {-7,8} can be described by the sequence {1,2}. The sequences {2,3}, {2,2,1}, and {4,1} describe different three valid ways of partitioning the sequence {0,1,0,1,2}.   You are given the int[] a. If this array is positive partitionable, find any valid way to partition it and return a int[] that describes it (as defined in the previous paragraph). If this array isn't positive partitionable, return {-1} instead. ", "pruebas": "[[\"{3,-7,8}\", \"Returns: {1, 2 }\"], [\"{0,1,0,1,2}\", \"Returns: {4, 1 }\"], [\"{-1,2,-3,4,-5}\", \"Returns: {-1 }\"], [\"{0}\", \"Returns: {-1 }\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15594"},
{"titulo": "LoopsyDoopsy", "categoria": "[\"Greedy\"]", "dificultad": "Facil", "enunciado": " The number of loops in a digit is the number of closed regions you produce when you write the digit on paper.  For example, \"1\" has no loops, \"9\" has one loop, and \"8\" has two. (As the number of loops depends on the font you use, the exact numbers of loops we are using in this problem are given in the Notes.)   By extension, the number of loops in any nonnegative integer is the total number of loops in its individual digits. For example, \"2461\" has two loops and \"1890\" has four.   You are given the int loops. Find the smallest nonnegative integer with exactly loops loops and return it as a String. Note that the returned String cannot have unnecessary leading zeros. ", "pruebas": "[[\"1\", \"Returns: \\\"0\\\"\"], [\"2\", \"Returns: \\\"8\\\"\"], [\"40\", \"Returns: \\\"88888888888888888888\\\"\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15562"},
{"titulo": "BagsOfMarbles", "categoria": "[\"Greedy\", \"SimpleMath\", \"SimpleSearch\", \"Iteration\"]", "dificultad": "Facil", "enunciado": " You want to have desired white marbles. Currently you have none. All the marbles are in bags owned by your friend. Each of your friend's bags contains exactly bagSize marbles. Each of those marbles is either white (you want those) or black (you don't care about those).   Your friends has bags of four types:  no white marblesnoWhiteBagsno black marblesnoBlackBagssome white marblessomeWhiteBagssome black marblessomeBlackBags  You are going to take marbles from your friend's bags, one at a time. More precisely, in each step you may choose any specific bag owned by your friend and take one random marble from that bag.   Return the smallest X such that you can be sure to reach your goal after taking X marbles (provided that you choose the bags in a smart way). If it's impossible to give such a guarantee, return -1 instead. ", "pruebas": "[[\"5\", \"10\", \"0\", \"1\", \"0\", \"0\", \"Returns: 5\"], [\"2\", \"10\", \"2\", \"0\", \"1\", \"0\", \"Returns: -1\"], [\"51\", \"7\", \"7\", \"7\", \"7\", \"7\", \"Returns: 63\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15827"},
{"titulo": "ChristmasCrackers", "categoria": "[\"Greedy\", \"SimpleMath\"]", "dificultad": "Facil", "enunciado": " A Christmas er is a festive table decoration that resembles an oversized sweet-wrapper. The middle part of a er usually contains some small gift and a terrible Christmas pun. (\"What does Santa feel when going down a narrow chimney? Claus-trophobia!\") It is customary that each er should be opened by two people. Each person takes hold of one outer chamber and they pull in opposite directions, causing the er to split unevenly and leaving one person holding the central chamber and the prize.   N people (numbered 0 to N-1) are attending a Christmas party. Each person would like to open at least K Christmas ers. What is the smallest total number C of ers they need, and how should they open them?   You are given the ints N and K. Return a int[] with 2*C elements: for each er, the numbers of the two people who should open it. Any valid solution will be accepted. ", "pruebas": "[[\"2\", \"3\", \"Returns: {0, 1, 0, 1, 0, 1 }\"], [\"5\", \"1\", \"Returns: {0, 3, 1, 2, 1, 4 }\"], [\"3\", \"4\", \"Returns: {0, 1, 0, 1, 0, 2, 0, 2, 1, 2, 2, 1 }\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15833"},
{"titulo": "CheatingAfterTests", "categoria": "[\"Greedy\", \"SimpleMath\", \"SimpleSearch\", \"Iteration\"]", "dificultad": "Facil", "enunciado": " In school you took some tests. Your score on each test was an integer between 0 (worst) and 99 (best), inclusive. After all the tests were done, you were given the report where all your scores are written. You are supposed to bring the report home and show it to your parents.   You aren't too happy with your scores, so you decided to improve the report: you may change any one digit to any other digit.   Do the change that will improve your report as much as possible. Compute and return the largest possible sum of all scores on your report card after you change up to one digit in one of the numbers. ", "pruebas": "[[\"{51, 47, 93}\", \"Returns: 241\"], [\"{99, 99}\", \"Returns: 198\"], [\"{4, 5, 7, 2}\", \"Returns: 25\"], [\"{93, 97, 92, 99, 92, 93}\", \"Returns: 573\"], [\"{94, 6, 1, 4}\", \"Returns: 113\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15901"},
{"titulo": "OppositeParity", "categoria": "[\"Greedy\", \"SimpleSearch\", \"Iteration\", \"Sorting\"]", "dificultad": "Facil", "enunciado": " You are given a int[] A. Your task is to  the elements of A in such a way that the parity of each element changes. That is:    If there are multiple valid solutions, you may return any one of them. If there are no valid solution, return an empty int[]. ", "pruebas": "[[\"{1, 4, 1, 4, 2, 1, 3, 5, 6, 2}\", \"Returns: {6, 1, 2, 3, 1, 4, 2, 4, 5, 1 }\"], [\"\\n1, 4, 1, 4, 2, 1, 3, 5, 6, 2\\n6, 1, 2, 3, 1, 4, 2, 4, 5, 1\\n\", \"{1, 1, 2}\", \"Returns: { }\"], [\"{3, 1, 4, 1, 5, 9}\", \"Returns: { }\"], [\"{27, 18, 281, 828, 45, 90, 452, 3}\", \"Returns: {452, 3, 90, 45, 828, 281, 27, 18 }\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15945"},
{"titulo": "EasyPartition", "categoria": "[\"BruteForce\", \"Greedy\", \"SimpleMath\"]", "dificultad": "Facil", "enunciado": " Ramanujan loved partitions. And he also loved natural numbers. So, yay! He has a problem for you.   The set S consists of the first 8*N natural numbers: S = { 1, 2, 3, ..., 8*N }. You have to find a subset W of S with the following properties:  NNN  If there is a subset W satisfying the mentioned condition, find any one such subset. Return a string of size 8*N, where the ith character (1-indexed) is '1' if i belongs to W, and '0' otherwise. Any valid solution will be accepted.   Return an empty string if it is impossible to construct a valid subset for the given N. ", "pruebas": "[[\"1\", \"Returns: \\\"10100000\\\"\"], [\"W = {1,3} satisfies our conditions.\", \"2\", \"Returns: \\\"0110110000000000\\\"\"], [\" \\n4 * N * N = 16.\\nW={2,3,5,7}\\nOther possible solutions are {1,3,5,7}, {1,2,6,7}, {1,2,5,8} etc.\\n\", \"3\", \"Returns: \\\"010110110100000000000000\\\"\"], [\"W = {2,4,5,7,8,10} satisfies.\", \"4\", \"Returns: \\\"01010110110101000000000000000000\\\"\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15977"},
{"titulo": "BootsExchange", "categoria": "[\"Greedy\"]", "dificultad": "Facil", "enunciado": " A boot shop has received a shipment from the factory consisting of N left boots and N right boots. Each boot has some integer size, and a left and right boot will form a proper pair if they have equal sizes. Each boot can only belong to a single pair. The employees of the boot store want to create N proper pairs of boots.  Fortunately, the factory has offered to exchange any number of boots in the shipment with new boots of different sizes.    You are given a int[] left and a int[] right containing the sizes of the left boots and right boots, respectively. Return the least number of boots that must be exchanged. ", "pruebas": "[[\"{1, 3, 1}\", \"{2, 1, 3}\", \"Returns: 1\"], [\"{1, 3}\", \"{2, 2}\", \"Returns: 2\"], [\"{1, 2, 3, 4, 5, 6, 7}\", \"{2, 4, 6, 1, 3, 7, 5}\", \"Returns: 0\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6081"},
{"titulo": "Palindromize", "categoria": "[\"Greedy\", \"Search\"]", "dificultad": "Facil", "enunciado": " A palindrome is a string that reads the same from left to right as it does from right to left.  Given a String s, return the shortest palindrome that can be produced by adding zero or more characters to the right end of s.  There is always one unique answer. ", "pruebas": "[[\"\\\"add\\\"\", \"Returns: \\\"adda\\\"\"], [\"\\\"cigartragic\\\"\", \"Returns: \\\"cigartragic\\\"\"], [\"\\\"redocpot\\\"\", \"Returns: \\\"redocpotopcoder\\\"\"], [\"\\\"acaba\\\"\", \"Returns: \\\"acabaca\\\"\"], [\"\\\"abczyxyz\\\"\", \"Returns: \\\"abczyxyzcba\\\"\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=7279"},
{"titulo": "Palindromize2", "categoria": "[\"Greedy\", \"Search\"]", "dificultad": "Facil", "enunciado": " A palindrome is a string that reads the same from left to right as it does from right to left.  Given a String s, return a palindrome that is produced by changing the minimum possible  number of characters in s. Changing a character means replacing it with any single character at the same position.  You are not allowed to remove or add any characters. If there are multiple answers, return the one that comes first alphabetically. ", "pruebas": "[[\"\\\"ameba\\\"\", \"Returns: \\\"abeba\\\"\"], [\"\\\"cigartragic\\\"\", \"Returns: \\\"cigartragic\\\"\"], [\"\\\"abcdef\\\"\", \"Returns: \\\"abccba\\\"\"], [\"\\\"cxbpaxz\\\"\", \"Returns: \\\"cxapaxc\\\"\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=7406"},
{"titulo": "OptimalList", "categoria": "[\"Greedy\", \"Simulation\"]", "dificultad": "Facil", "enunciado": " Billy is going to his grandmother's house. To help him do that, his mother has written down a detailed list of instructions for him to follow. Each instruction is a character 'N', 'S', 'W' or 'E', telling him to go exactly 1 block to the north, south, west or east, respectively. Billy's city consists of an infinitely large grid of streets, where each street extends infinitely to both sides, and the space between 2 adjacent streets going in the same direction is always 1 block.  Billy's house and his grandmother's house are both located at street corners in this city.  Billy knows that his mother does not always choose the shortest path.  Therefore, he wants to make a new list of instructions that will also lead him to his grandmother's house, but uses the minimum possible number of instructions.  You will be given inst, a String with the original list made by Billy's mom. Return the new list Billy wants. If there are several solutions, return the one that comes first alphabetically. ", "pruebas": "[[\"\\\"NENENNWWWWWS\\\"\", \"Returns: \\\"NNNWWW\\\"\"], [\"\\\"NNEESSWW\\\"\", \"Returns: \\\"\\\"\"], [\"\\\"NEWSNWESWESSEWSENSEWSEWESEWWEWEEWESSSWWWWWW\\\"\", \"Returns: \\\"SSSSSSSSWWW\\\"\"], [\"\\\"NENENE\\\"\", \"Returns: \\\"EEENNN\\\"\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=7752"},
{"titulo": "BoxesOfBooks", "categoria": "[\"Greedy\", \"SimpleMath\"]", "dificultad": "Facil", "enunciado": " You are packing a stack of books into some , packing as many books as you can into each box without exceeding a given weight limit. Once you have packed as many books into a box as you can, you close and seal that box, and then begin filling the next one. You take the books off the stack in order, packing each one before picking up the next.    The weights of the books will be given as a int[] weights, where the first element is the weight of the book on top of the stack and the last element is the weight of the book on the bottom of the stack. The maximum weight that can fit into each box will be given as an int maxWeight. Return the minimum number of  you will need.  ", "pruebas": "[[\"{ 5, 5, 5, 5, 5, 5 }\", \"10\", \"Returns: 3\"], [\"{ 51, 51, 51, 51, 51 }\", \"100\", \"Returns: 5\"], [\"{ 1, 1, 1, 7, 7, 7 }\", \"8\", \"Returns: 4\"], [\"{ 12, 1, 11, 2, 10, 3, 4, 5, 6, 6, 1 }\", \"12\", \"Returns: 6\"], [\"{ }\", \"7\", \"Returns: 0\"], [\"{ 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\\n  20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\\n  20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\\n  20, 20, 20, 20, 20, 20, 20, 20, 20, 20,\\n  20, 20, 20, 20, 20, 20, 20, 20, 20, 20 }\", \"1000\", \"Returns: 1\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8559"},
{"titulo": "ReadingBooks", "categoria": "[\"Greedy\", \"SimpleSearch\", \"Iteration\"]", "dificultad": "Facil", "enunciado": " \tThere are some books, each consisting of exactly three parts: introduction, story and edification.  \tThere is a reader who goes through the books and reads various parts.  \tEach time he finishes reading a part, he adds the name of the part to the end of a list.  \tHe may read zero or more parts from each book, and he can read them in any order, but he cannot  \tread each part more than once.  \tWhenever he starts reading a new book, he can no longer go back and read any parts of books he has  \tlooked at previously.   \tYou are given a String[] readParts containing the list created by the reader.  \tEach element of readParts is \"introduction\", \"story\" or \"edification\" (quotes for clarity).  \tReturn the maximum possible number of books for which the reader has read all three parts.  ", "pruebas": "[[\"{\\\"introduction\\\", \\\"story\\\", \\\"introduction\\\", \\\"edification\\\"}\", \"Returns: 1\"], [\"{\\\"introduction\\\", \\\"story\\\", \\\"edification\\\", \\\"introduction\\\", \\\"story\\\", \\\"edification\\\"}\", \"Returns: 2\"], [\"{\\\"introduction\\\", \\\"story\\\", \\\"introduction\\\", \\\"edification\\\", \\\"story\\\", \\\"introduction\\\"}\", \"Returns: 1\"], [\"{\\\"introduction\\\", \\\"story\\\", \\\"introduction\\\", \\\"edification\\\", \\\"story\\\",\\n \\\"story\\\", \\\"edification\\\", \\\"edification\\\", \\\"edification\\\", \\\"introduction\\\",\\n \\\"introduction\\\", \\\"edification\\\", \\\"story\\\", \\\"introduction\\\", \\\"story\\\",\\n \\\"edification\\\", \\\"edification\\\", \\\"story\\\", \\\"introduction\\\", \\\"edification\\\",\\n \\\"story\\\", \\\"story\\\", \\\"edification\\\", \\\"introduction\\\", \\\"story\\\"}\", \"Returns: 5\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8216"},
{"titulo": "PackingParts", "categoria": "[\"Greedy\"]", "dificultad": "Facil", "enunciado": " Given a set of parts and a set of boxes, you are asked to determine how many of the parts can be ed into  boxes. You can put at most one part into each box. In order for a part to fit into a box, the box must be the same size as or larger than the part. You follow the following process when ing the parts:     You are given a int[] partSizes containing the sizes of the parts, and a int[] boxSizes containing the sizes of the boxes. Both int[]s will be sorted in non-descending order.   Return an int representing the maximum number of parts you can  by following the process above. ", "pruebas": "[[\"{2,2,2}\", \"{1,2,2,3}\", \"Returns: 3\"], [\"{1,5}\", \"{2,5}\", \"Returns: 2\"], [\"{10,10,10,10}\", \"{9,9,9,10,10,10}\", \"Returns: 3\"], [\"{1,1,1,1}\", \"{1,2,2,3,6,7}\", \"Returns: 4\"], [\"{1,1,1,1}\", \"{2,3,6}\", \"Returns: 3\"], [\"{10,32,46,55,55,84,100}\", \"{15,31,34,46,59,68,83,99}\", \"Returns: 6\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6139"},
{"titulo": "SortMachine", "categoria": "[\"Greedy\", \"Sorting\"]", "dificultad": "Facil", "enunciado": "We have a sorting machine that works on a list of distinct numbers.  This machine only has one instruction named  that takes one element of the list as a parameter.  The  instruction removes the element from the list and then appends it to the end of the remaining list. For example, the sequence {19,7,8,25} can be sorted in ascending order using 2 instructions: , to get {7,8,25,19} , to get {7,8,19,25} You will be given a int[] a containing a list of distinct numbers.  Return the minimum number of instructions required to sort the list in ascending order.", "pruebas": "[[\"{19,7,8,25}\", \"Returns: 2\"], [\"{1,2,3,4,5}\", \"Returns: 0\"], [\"{1000,-1000,0}\", \"Returns: 1\"], [\"{1,3,4,5,6,7,8,9,2}\", \"Returns: 7\"], [\"{-2, -8, 9, 0}\", \"Returns: 3\"], [\"{976, -946, -824, 680, -644, -95, 128, -892, 816, -263,\\n -592, -669, 887, 447, -653, -759, 572, 171, 635, 98,\\n -904, 78, 143, -416, -40, -846, 784, -702, -738, -858,\\n 582, 603, -535, 529, 84, -964, 934, 36, 783} \", \"Returns: 38\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6413"},
{"titulo": "LinearPolyominoCovering", "categoria": "[\"Greedy\"]", "dificultad": "Facil", "enunciado": "You have an infinite number of the following two polyominoes: AAAA and BB.  You are given a String region, filled with characters '.' and 'X'. You need to cover (without overlapping) all the 'X' characters with the given polyominoes.  Return a String that contains the same region with cells marked '.' left untouched, and cells marked 'X' changed to 'A' or 'B', according to the polyomino that covers the cell.  If there is no solution, return the String \"impossible\" (quotes for clarity only).  If there are multiple solutions, return the lexicographically smallest one. ", "pruebas": "[[\"\\\"XXXXXX\\\"\", \"Returns: \\\"AAAABB\\\"\"], [\"\\\"XX.XX\\\"\", \"Returns: \\\"BB.BB\\\"\"], [\"\\\"XXXX....XXX.....XX\\\"\", \"Returns: \\\"impossible\\\"\"], [\"\\\"X\\\"\", \"Returns: \\\"impossible\\\"\"], [\"\\\"XX.XXXXXXXXXX..XXXXXXXX...XXXXXX\\\"\", \"Returns: \\\"BB.AAAAAAAABB..AAAAAAAA...AAAABB\\\"\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=10251"},
{"titulo": "CreateGroups", "categoria": "[\"Greedy\", \"SimpleMath\"]", "dificultad": "Facil", "enunciado": "Your language school is starting a new semester, and each student must select a time schedule.  You are given a int[] groups, where the i-th element is the number of students who selected the i-th schedule.  Your school has a rule stating that the number of students assigned to each schedule must be between minSize and maxSize, inclusive.  However, this rule was not enforced properly during the sign up phase.  It is your job to reassign students in such a way that the rule is satisfied.  A reassignment is defined as removing a student from one time schedule and placing him in a different time schedule.  Return the minimal number of students you must reassign, or return -1 if it is impossible to satisfy the rule.  Note that you may not create new schedules or delete existing schedules.", "pruebas": "[[\"{10,20}\", \"10\", \"15\", \"Returns: 5\"], [\"{20,8,6}\", \"10\", \"15\", \"Returns: 6\"], [\"{10,20,30}\", \"1\", \"18\", \"Returns: -1\"], [\"{50,10,20,20,5}\", \"15\", \"30\", \"Returns: 20\"], [\"{100,200,301}\", \"200\", \"200\", \"Returns: -1\"], [\"{1,10,10}\\t\", \"9\", \"20\", \"Returns: -1\"], [\"{55,33,45,71,27,89,16,14,61}\", \"33\", \"56\", \"Returns: 53\"], [\"{49,60,36,34,36,52,60,43,52,59}\", \"45\", \"51\", \"Returns: 31\"], [\"{5,5,5,5,5}\", \"5\", \"5\", \"Returns: 0\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8376"},
{"titulo": "DifferentStrings", "categoria": "[\"BruteForce\", \"Greedy\", \"Simulation\", \"StringManipulation\"]", "dificultad": "Facil", "enunciado": "If X and Y are two Strings of equal length N, then the difference between them is defined as the number of indices i where the i-th character of X and the i-th character of Y are different.  For example, the difference between the words \"ant\" and \"art\" is 1.  You are given two Strings, A and B, where the length of A is less than or equal to the length of B.  You can apply an arbitrary number of operations to A, where each operation is one of the following:  AA  Apply the operations in such a way that A and B have the same length and the difference between them is as small as possible.  Return this minimum possible difference.", "pruebas": "[[\"\\\"koder\\\"\", \"\\\"topcoder\\\"\", \"Returns: 1\"], [\"\\\"hello\\\"\", \"\\\"xello\\\"\", \"Returns: 1\"], [\"\\\"abc\\\"\", \"\\\"topabcoder\\\"\", \"Returns: 0\"], [\"\\\"adaabc\\\"\", \"\\\"aababbc\\\"\", \"Returns: 2\"], [\"\\\"giorgi\\\"\", \"\\\"igroig\\\"\", \"Returns: 6\"]]", "url": "https://community.topcoder.com/stat?c=problem_statement&pm=10376"}
][
{"titulo": "UnstableString", "categoria": "[\"binary search\", \"dp\", \"greedy\", \"implementation\", \"strings\", \"two pointers\"]", "dificultad": "Facil", "enunciado": "You are given a string s consisting of the characters 0, 1, and ?.Let's call a string unstable if it consists of the characters 0 and 1 and any two adjacent characters are different (i.\u00a0e. it has the form 010101... or 101010...).Let's call a string beautiful if it consists of the characters 0, 1, and ?, and you can replace the characters ? to 0 or 1 (for each character, the choice is independent), so that the string becomes unstable.For example, the strings 0??10, 0, and ??? are beautiful, and the strings 00 and ?1??1 are not.Calculate the number of beautiful contiguous substrings of the string s.", "pruebas": "[[\"\\n3\\n0?10\\n???\\n?10??1100\\n\", \"Returns: \\n8\\n6\\n25\\n\"]]", "url": "https://codeforces.com//problemset/problem/1535/C"},
{"titulo": "SubsetMex", "categoria": "[\"greedy\", \"implementation\", \"math\"]", "dificultad": "Facil", "enunciado": "Given a set of integers (it can contain equal elements).You have to split it into two subsets A and B (both of them can contain equal elements or be empty). You have to maximize the value of mex(A)+mex(B).Here mex of a set denotes the smallest non-negative integer that doesn't exist in the set. For example:  mex(\\{1,4,0,2,2,1\\})=3  mex(\\{3,3,2,1,3,0,0\\})=4  mex(\\varnothing)=0 (mex for empty set) The set is splitted into two subsets A and B if for any integer number x the number of occurrences of x into this set is equal to the sum of the number of occurrences of x into A and the number of occurrences of x into B.", "pruebas": "[[\"\\n4\\n6\\n0 2 1 5 0 1\\n3\\n0 1 2\\n4\\n0 2 0 1\\n6\\n1 2 3 4 5 6\\n\", \"Returns: \\n5\\n3\\n4\\n0\\n\"]]", "url": "https://codeforces.com//problemset/problem/1406/A"},
{"titulo": "PINCodes", "categoria": "[\"greedy\", \"implementation\"]", "dificultad": "Facil", "enunciado": "A PIN code is a string that consists of exactly 4 digits. Examples of possible PIN codes: 7013, 0000 and 0990. Please note that the PIN code can begin with any digit, even with 0.Polycarp has n (2 \\le n \\le 10) bank cards, the PIN code of the i-th card is p_i.Polycarp has recently read a recommendation that it is better to set different PIN codes on different cards. Thus he wants to change the minimal number of digits in the PIN codes of his cards so that all n codes would become different.Formally, in one step, Polycarp picks i-th card (1 \\le i \\le n), then in its PIN code p_i selects one position (from 1 to 4), and changes the digit in this position to any other. He needs to change the minimum number of digits so that all PIN codes become different.Polycarp quickly solved this problem. Can you solve it?", "pruebas": "[[\"\\n3\\n2\\n1234\\n0600\\n2\\n1337\\n1337\\n4\\n3139\\n3139\\n3139\\n3139\\n\", \"Returns: \\n0\\n1234\\n0600\\n1\\n1337\\n1237\\n3\\n3139\\n3138\\n3939\\n6139\\n\"]]", "url": "https://codeforces.com//problemset/problem/1263/B"},
{"titulo": "RelativelyPrimePairs", "categoria": "[\"greedy\", \"math\", \"number theory\"]", "dificultad": "Facil", "enunciado": "You are given a set of all integers from l to r inclusive, l < r, (r - l + 1) \\le 3 \\cdot 10^5 and (r - l) is always odd.You want to split these numbers into exactly \\frac{r - l + 1}{2} pairs in such a way that for each pair (i, j) the greatest common divisor of i and j is equal to 1. Each number should appear in exactly one of the pairs.Print the resulting pairs or output that no solution exists. If there are multiple solutions, print any of them.", "pruebas": "[[\"1 8\", \"Returns: YES\"]]", "url": "https://codeforces.com//problemset/problem/1051/B"},
{"titulo": "ProblemsforRound", "categoria": "[\"greedy\", \"implementation\"]", "dificultad": "Facil", "enunciado": "There are  problems prepared for the next Codeforces round. They are arranged in ascending order by their difficulty, and no two problems have the same difficulty. Moreover, there are  pairs of similar problems. Authors want to split problems between two division according to the following rules:  Problemset of each division should be non-empty.  Each problem should be used in exactly one division (yes, it is unusual requirement).  Each problem used in division 1 should be harder than any problem used in division 2.  If two problems are similar, they should be used in different divisions. Your goal is count the number of ways to split problem between two divisions and satisfy all the rules. Two ways to split problems are considered to be different if there is at least one problem that belongs to division 1 in one of them and to division 2 in the other.Note, that the relation of similarity is not transitive. That is, if problem  is similar to problem  and problem  is similar to problem , it doesn't follow that  is similar to .", "pruebas": "[[\"5 2\", \"1 4\", \"5 2\", \"Returns: 2\"], [\"3 3\", \"1 2\", \"2 3\", \"1 3\", \"Returns: 0\"], [\"3 2\", \"3 1\", \"3 2\", \"Returns: 1\"]]", "url": "https://codeforces.com//problemset/problem/673/B"},
{"titulo": "MagicNumbers", "categoria": "[\"brute force\", \"greedy\"]", "dificultad": "Facil", "enunciado": "A magic number is a number formed by concatenation of numbers 1, 14 and 144. We can use each of these numbers any number of times. Therefore 14144, 141414 and 1411 are magic numbers but 1444, 514 and 414 are not.You're given a number. Determine if it is a magic number or not.", "pruebas": "[[\"114114\", \"Returns: YES\"], [\"1111\", \"Returns: YES\"], [\"441231\", \"Returns: NO\"]]", "url": "https://codeforces.com//problemset/problem/320/A"}
]