[
{"titulo": "ChristmasBatteries", "categoria": ["BruteForce", "DynamicProgramming", "Greedy"], "dificultad": "Facil", "enunciado": " Peter is very fond of his niece Emily. For Christmas, Peter wants to give his niece a collection of various toys. He has already purchased N toys. However, at the last moment Peter realized that he probably cannot give Emily all the toys.   The problem is that many of the toys require batteries, and those are not included in the package. Peter forgot to purchase batteries and now he could only find very few of them: he only has B batteries. And there's nothing worse than getting a toy that does not work because it lacks batteries. (Well, there are surely plenty of worse things, but not in Emily's world.)   Hence, Peter came to the following conclusion: he will only give Emily a subset of the toys he has purchased. The toys given to Emily must require at most B batteries in total.   The toys are numbered from 0 to N-1, inclusive. Toy i requires (i mod 5) batteries. The amount of fun from toy i is ((X*i*i + Y*i + Z) mod M).   The amount of fun from a collection of toys is simply the sum of amounts of fun from the individual toys in the collection. Find the collection of toys Peter should give Emily if he wants her to have as much fun as possible with the toys. Return the total amount of fun for that collection. ", "pruebas": {"caso 1": ["0", "5", "1", "1", "1", "1000", "Returns: 1"], "caso 2": ["3", "5", "1", "1", "1", "1000", "Returns: 14"], "caso 3": ["3", "5", "1", "1", "1", "13", "Returns: 11"], "caso 4": ["4", "10000", "123", "456", "789", "1", "Returns: 0"], "caso 5": ["7", "4", "3", "5", "7", "997", "Returns: 100"], "caso 6": ["2", "12345", "234", "34", "5", "117", "Returns: 143371"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=16717"},
{"titulo": "IdenticalBags", "categoria": ["Greedy", "Math", "Search"], "dificultad": "Facil", "enunciado": " You are preparing for Halloween. You like to hand out bags of candy. In order to prevent arguments between the kids who get them, you want all bags to be identical.   You have a supply of various candy. Each element of candy is the number of pieces of a specific candy type. You want to create bags that will contain bagSize pieces of candy each. Compute and return the maximum number of identical bags you can make. ", "pruebas": {"caso 1": ["{10, 11, 12}", "3", "Returns: 10"], "caso 2": ["{10, 11, 12, 1, 2, 3}", "3", "Returns: 10"], "caso 3": ["{100}", "7", "Returns: 14"], "caso 4": ["{10000000000, 20000000000, 30000000000}", "6", "Returns: 10000000000"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15305"},
{"titulo": "NewBanknote", "categoria": ["Greedy"], "dificultad": "Facil", "enunciado": " In this problem we use the Euro currency. One euro equals 100 cents. All amounts in this problem will be in cents to avoid dealing with non-integer numbers.   Euro coins have the following denominations: 1, 2, 5, 10, 20, 50, 100, and 200 cents. Euro banknotes have the following denominations: 500, 1000, 2000, 5000, 10000, 20000, and 50000 cents.   There are rumors that the European Committee will soon introduce a new banknote worth newBanknote cents.   In this new monetary system, what will be the smallest number of coins and banknotes needed to pay exactly X cents?   You are given the int[] amountsToPay. For each X in amountsToPay answer the above question. Return a int[] containing the answers. ", "pruebas": {"caso 1": ["4700", "{53, 9400, 9401, 30000}", "Returns: {3, 2, 3, 2 }"], "caso 2": ["1234", "{1233, 1234, 1235}", "Returns: {6, 1, 2 }"], "caso 3": ["1000", "{1233, 100047}", "Returns: {6, 6 }"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15439"},
{"titulo": "AddPeriodic", "categoria": ["Greedy", "Math", "SimpleSearch", "Iteration"], "dificultad": "Facil", "enunciado": " You are given two Strings A and B, each containing the representation of a nonnegative periodic decimal. More precisely, A and B are each given in the form \"X.Y(Z)\", where:    Y is called the pre-period and Z is called the period. For example, \"0.(3)\" and \"0.33(333)\" are two valid representations of the number 1/3, and \"12.(0)\" and \"11.(9)\" are two valid representations of the number twelve.   Let C = A + B. Return a String containing a representation of C in the same format. Minimize the length of the pre-period and also the length of the period in the representation of C. If the period can be either 0 or 9, use 0. ", "pruebas": {"caso 1": ["\"0.33(333)\"", "\"0.(66)\"", "Returns: \"1.(0)\""], "caso 2": ["\"2.41(5)\"", "\"5.36(22)\"", "Returns: \"7.(7)\""], "caso 3": ["\"685.4(757)\"", "\"45.356(43)\"", "Returns: \"730.832(210119)\""], "caso 4": ["\"0.(101)\"", "\"0.(23)\"", "Returns: \"0.(333424)\""], "caso 5": ["\"0.0(999999)\"", "\"1.5(00000)\"", "Returns: \"1.6(0)\""]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15579"},
{"titulo": "FixedPointReversals", "categoria": ["Greedy"], "dificultad": "Facil", "enunciado": " You are given the int[] A with N elements. Your task is to  it into the usual non-decreasing order.   The only way in which you can modify A is by reversing some segments of A. In each step you can specify indices i, j such that 0 <= i < j <= N, and reverse the segment A[i:j] = { A[i], ..., A[j-1] }.   There is one extra restriction: The operations must never change the value of the element at index fixed.   If there is no way to  A, return {-1}. Otherwise, find any solution with at most 75 reversals and return a int[] of the form { i1, j1, i2, j2, ... } that describes the sequence of reversals you wish to perform. ", "pruebas": {"caso 1": ["{10, 20, 30, 40, 50}", "2", "Returns: { }"], "caso 2": ["{10, 20, 40, 30, 50}", "2", "Returns: {-1 }"], "caso 3": ["{20, 10, 10, 10, 10, 10}", "4", "Returns: {0, 6 }"], "caso 4": ["{1, 50, 40, 30, 20, 10}", "0", "Returns: {1, 6 }"], "caso 5": ["{20, 10, 30, 50, 40}", "2", "Returns: {0, 2, 3, 5 }"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15693"},
{"titulo": "PrimePruning", "categoria": ["BruteForce", "Greedy", "SimpleMath", "SimpleSearch", "Iteration"], "dificultad": "Facil", "enunciado": " An integer is a prime number if it has exactly two positive integer divisors. The first few prime numbers are P[0]=2, P[1]=3, P[2]=5, and so on.   Let alphabet[x] denote the x-th (0-based index) lowercase letter of the English alphabet. For example, alphabet[0]='a' and alphabet[24]='y'.   You are given the ints N and E. Generate an N-character string by concatenating alphabet[P[i] mod 26] for i=0..N-1. Then, produce the lexicographically largest possible string by erasing exactly E of those characters. Return that string. ", "pruebas": {"caso 1": ["10", "0", "Returns: \"cdfhlnrtxd\""], "caso 2": ["30", "5", "Returns: \"nrtxdflprvbhjptvbfltxzdfj\""], "caso 3": ["30", "15", "Returns: \"xvjptvbfltxzdfj\""]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15755"},
{"titulo": "DeleteArrays", "categoria": ["BruteForce", "Greedy", "Math", "Sorting"], "dificultad": "Facil", "enunciado": " You are given three numbers: a, b, and c. You need to generate three arrays A, B, C of lengths a, b, c using the pseudocode given below:    Now that you have 3 arrays A , B and C, you can perform three types of moves:   xyz  You need to minimize the sum of elements remaining in these arrays after performing above mentioned operations any number of times. If there are multiple ways to obtain the minimum sum, you need to minimize the cost of doing so.    Return an array of two integers containing the minimum sum (at index 0) and minimum cost of obtaining the minimum sum (at index 1). ", "pruebas": {"caso 1": ["\nA[0] = 33\nA[1] = 42\nfor i = 2 to a-1:\n    A[i] = (5*A[i-1] + 7*A[i-2]) modulo 1000000007 + 1\n\nB[0] = 13\nfor i = 1 to b-1:\n    B[i] = (11*B[i-1]) modulo 1000000007 + 1\n\nC[0] = 7\nC[1] = 2\nfor i = 2 to c-1:\n    C[i] = (5*C[i-1] + 7*C[i-2]) modulo 1000000007 + 1\n", "2", "2", "2", "2", "3", "4", "Returns: {0, 250 }"], "caso 2": ["3", "2", "2", "3", "2", "1", "Returns: {2, 688 }"], "caso 3": ["4", "4", "4", "5", "6", "7", "Returns: {0, 22620 }"], "caso 4": ["100000", "5", "8", "424242", "474747", "123456789", "Returns: {50097960828195, 13989929548 }"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15738"},
{"titulo": "LandSplitter", "categoria": ["BruteForce", "Greedy", "Math", "SimpleSearch", "Iteration"], "dificultad": "Facil", "enunciado": " A lord owned a piece of land with area N. He wanted to give parts of this land as rewards to his subjects, so he decided that he will split the piece of land into one or more pieces in such a way that the size of each piece will be between A and B, inclusive. But splitting pieces of land is regulated by the king of this country, as follows:    Return -1 if the lord cannot reach his goal. Otherwise, return the smallest total amount of taxes with which the lord can reach his goal. ", "pruebas": {"caso 1": ["12", "3", "3", "Returns: 54"], "caso 2": ["10", "3", "4", "Returns: 33"], "caso 3": ["47", "1", "47", "Returns: 0"], "caso 4": ["70", "40", "50", "Returns: -1"], "caso 5": ["47", "4", "7", "Returns: 945"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=15869"},
{"titulo": "GoldMining", "categoria": ["Greedy", "Math"], "dificultad": "Facil", "enunciado": " You just found a gold mine that contains goldInGround units of gold. Currently, you don't have any units of gold. You have miningTime minutes of time. Once that time elapses, you want to have as much gold as possible.   You can mine the gold yourself, at the rate of one unit of gold per minute. At the beginning of each minute, you can also hire as many additional workers as you wish. Each worker requires an immediate one-time payment of hiringCost gold. (You can only hire a worker if you have enough gold to pay them.) A hired worker mines gold at the same rate as you. All gold mined by the workers belongs to you.   Return the maximum amount of gold you can have after miningTime minutes. ", "pruebas": {"caso 1": ["470000", "1000000", "50", "Returns: 470000"], "caso 2": ["470000", "100000", "1234567890123456", "Returns: 100000"], "caso 3": ["470000", "100000", "57000", "Returns: 100000"], "caso 4": ["470000", "100000", "42000", "Returns: 116000"], "caso 5": ["567890", "4", "1", "Returns: 8"], "caso 6": ["234567", "47", "10", "Returns: 215"], "caso 7": ["300", "47", "10", "Returns: 190"], "caso 8": ["987654321098765432", "100", "3", "Returns: 2731288513472"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=16617"},
{"titulo": "ValueDivision", "categoria": ["BruteForce", "Greedy", "SimpleMath"], "dificultad": "Facil", "enunciado": " You are given an int[] A of positive integers. In a single turn, you can do the following: Choose any value X that is greater than 1. Let C be the number of occurrences of X in the array A. You then subtract 1 from exactly C/2 (rounded down) of those occurrences.     Find the lexicographically smallest array you can obtain after performing any number of turns. ", "pruebas": {"caso 1": ["{1, 5, 7, 4, 5, 4, 1}", "Returns: {1, 2, 7, 3, 5, 4, 1 }"], "caso 2": ["{7}", "Returns: {7 }"], "caso 3": ["{7, 4}", "Returns: {7, 4 }"], "caso 4": ["{7, 7, 7, 7}", "Returns: {4, 5, 6, 7 }"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=16007"},
{"titulo": "Apothecary", "categoria": ["Greedy", "Math"], "dificultad": "Facil", "enunciado": " An accurate scale is one of the most important tools of the apothecary (an old-time pharmacist).   To measure the weight of an object, the apothecary places the object on one pan of the scale, along with some weights of known size, and adds more weights of known size to the other pan until the scales .  For example, if an object weighs 17 grains, the apothecary could  the scales by placing a 1-grain weight and a 9-grain weight in the pan with the object, and a 27-grain weight in the other pan.    The apothecary owns weights in a range of sizes starting at 1 grain.  In particular, he owns one weight for each power of 3: 1 grain, 3 grains, 9 grains, 27 grains, etc.  Determine, for an object weighing W grains, how to distribute the weights among the pans to  the object.  This distribution will be unique.  Return a int[] of the weights used.  The sign of each weight should be negative if the weight goes in the same pan as the object, and positive if it goes in the other pan.  The int[] should be arranged in increasing order.  ", "pruebas": {"caso 1": ["17", "Returns: { -9,  -1,  27 }"], "caso 2": ["1", "Returns: { 1 }"], "caso 3": ["2016", "Returns: { -243,  -9,  81,  2187 }"], "caso 4": ["1000000", "Returns: { -531441,  -59049,  -6561,  -243,  -27,  1,  81,  729,  2187,  1594323 }"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=2312"},
{"titulo": "CircleDance", "categoria": ["Greedy"], "dificultad": "Facil", "enunciado": "Given a group of dancers' heights, arrange a circle formation that minimizes the maximum height difference between each pair of neighboring dancers. Write a class CircleDance with a method  that takes a int[], heights, and returns the maximum height difference between neighboring dancers.", "pruebas": {"caso 1": ["{180,183,178,185}", "Returns: 5"], "caso 2": ["\n    180\n   /   \\\n185     178\n   \\   /\n    183\n", "\n    180\n(5)/   \\(2)\n185     178\n(2)\\   /(5)\n    183\n", "\n    180\n(3)/   \\(2)\n183     178\n(2)\\   /(7)\n    185\n", "{170,180,190}", "Returns: 20"], "caso 3": ["\n     180\n (10)/ \\(10)\n  170 - 190\n    (20)\n", "{180,180,180,180,180}", "Returns: 0"], "caso 4": ["{184,165,175,186,192,200,176,192,194,168,205,201}", "Returns: 10"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=4507"},
{"titulo": "NumericalSequence", "categoria": ["Greedy"], "dificultad": "Facil", "enunciado": "A numerical sequence is called a palindrome if the reverse of the sequence is the same as the original. For example sequences {1, 2, 1}, {15, 78, 78, 15} and {112} are palindromes, but {1, 2, 2}, {15, 78, 87, 51} and {112, 2, 11} are not. You will be given a int[] sequence. You can replace any two adjacent numbers with their sum. Your method should return a minimal number of such operations required to make the given sequence a palindrome. ", "pruebas": {"caso 1": ["{15,78,78,15}", "Returns: 0"], "caso 2": ["{1,1,1,3}", "Returns: 2"], "caso 3": ["{15,78,87,51}", "Returns: 3"], "caso 4": ["{3,23,21,23,42,39,63,76,13,13,13,32,12,42,26}", "Returns: 8"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=4619"},
{"titulo": "MatrixTransforming", "categoria": ["Greedy"], "dificultad": "Facil", "enunciado": "Given two matrices a and b, both composed of zeroes and ones, return the minimal number of operations necessary to transform matrix a into matrix b. An operation consists of flipping (one becomes zero and zero becomes one) all elements of some contiguous 3 x 3 submatrix. If a cannot be transformed into b, return -1.", "pruebas": {"caso 1": ["{\"111\",\"111\",\"111\"}", "{\"000\",\"000\",\"000\"}", "Returns: 1"], "caso 2": ["{\"1\"}", "{\"0\"}", "Returns: -1"], "caso 3": ["{\"001\",\"100\",\"100\",\"000\",\"011\",\"010\",\"100\",\"100\",\"010\",\n\"010\",\"010\",\"110\",\"101\",\"101\",\"000\",\"110\",\"000\",\"110\"}", "{\"001\",\"100\",\"011\",\"000\",\"100\",\"010\",\"011\",\"100\",\"101\",\n\"101\",\"010\",\"001\",\"010\",\"010\",\"111\",\"110\",\"111\",\"001\"}", "Returns: 7"], "caso 4": ["{\n\"0000\",\n\"0010\",\n\"0000\"\n}", "{\n\"1001\",\n\"1011\",\n\"1001\"\n}", "Returns: 2"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6431"},
{"titulo": "LuckySum", "categoria": ["BruteForce", "Greedy"], "dificultad": "Facil", "enunciado": " A lucky number is a positive integer such that each of its digits is a 4 or a 7. A lucky sum is the sum of two (not necessarily distinct) lucky numbers. Cat loves lucky sums!    Cat has a String note. Each character in note is either a digit or a question mark. A number matches note if it can be produced from note by changing each question mark to a single digit. Note that the number produced this way must not have any leading zeros: after the changes, note[0] must be between '1' and '9', inclusive.    Find and return the smallest lucky sum that matches note. If there are no lucky sums that match note, return -1. ", "pruebas": {"caso 1": ["\"?\"", "Returns: 8"], "caso 2": ["\"?1\"", "Returns: 11"], "caso 3": ["\"4?8\"", "Returns: 448"], "caso 4": ["\"2??\"", "Returns: -1"], "caso 5": ["\"??????????????\"", "Returns: 11888888888888"]}, "url": "https://community.topcoder.com/stat?c=problem_statement&pm=13964"}
]