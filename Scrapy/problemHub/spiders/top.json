[
{"titulo": "TheKingsFactorization", "categoria": "BruteForce,Greedy,Math", "dificultad": "Facil", "enunciado": " The King of Byteland likes integer factorization. Your task is to help him factor the number N. You will be given the long N and you should return a long[] containing all prime factors of N sorted in non-decreasing order. Note that some primes may occur multiple times in the prime factorization of N. For example, for N = 60 the only correct return value is {2, 2, 3, 5} because 2*2*3*5 = 60.     To make this task easier, the King has decided to give you a hint. He already knows the correct factorization and he will tell you every second number in the correct return value. More precisely, in addition to N you will be given a long[] primes. The number of elements in primes will be (M+1)/2, rounded down, where M is the number of elements in the correct return value. For each valid i, primes[i] will be equal to the element 2i of the correct return value. (All indices are 0-based.)     Given N and primes, return the long[] containing the factorization of N. ", "pruebas": ["12", "{2, 3}", "Returns: {2, 2, 3 }", "7", "{7}", "Returns: {7 }", "1764", "{2, 3, 7}", "Returns: {2, 2, 3, 3, 7, 7 }", "49", "{7}", "Returns: {7, 7 }", "210", "{2, 5}", "Returns: {2, 3, 5, 7 }", "100000", "{2, 2, 2, 5, 5}", "Returns: {2, 2, 2, 2, 2, 5, 5, 5, 5, 5 }"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=13594"},
{"titulo": "BallsSeparating", "categoria": "BruteForce,Greedy", "dificultad": "Facil", "enunciado": "There are N boxes numbered from 0 to N-1, inclusive. For each i, box i contains red[i] red balls, green[i] green balls, and blue[i] blue balls.   Fox Ciel wants to separate the balls by colors. In each operation, she can pick a single ball from some box and put it into another box. She considers the balls to be separated if no box contains balls of more than one color.   Return the minimal number of operations required to separate the balls. If this is impossible, return -1. ", "pruebas": ["{1, 1, 1}", "{1, 1, 1}", "{1, 1, 1}", "Returns: 6", "{5}", "{6}", "{8}", "Returns: -1", "{4, 6, 5, 7}", "{7, 4, 6, 3}", "{6, 5, 3, 8}", "Returns: 37", "{7, 12, 9, 9, 7}", "{7, 10, 8, 8, 9}", "{8, 9, 5, 6, 13}", "Returns: 77", "{842398, 491273, 958925, 849859, 771363, 67803, 184892, 391907, 256150, 75799}", "{268944, 342402, 894352, 228640, 903885, 908656, 414271, 292588, 852057, 889141}", "{662939, 340220, 600081, 390298, 376707, 372199, 435097, 40266, 145590, 505103}", "Returns: 7230607"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12398"},
{"titulo": "UndoHistory", "categoria": "Greedy,SimpleSearch,Iteration", "dificultad": "Facil", "enunciado": "Bob is using a peculiar text editor to write a sequence of lines of text. The editor consists of three parts: a results window, a text buffer and an undo history. More details about the three parts follow.   You are given a String[] lines. Bob would like to print the contents of lines into the results window. (At the end, the sequence of strings stored in the results window must be precisely equal to lines. Order of elements matters.) Additionally, Bob would like to do so as quickly as possible. He is able to take the following actions:    Return the minimum total number of button presses (keyboard and mouse) that Bob needs to print all the given lines into the results window.", "pruebas": ["{\"tomorrow\", \"topcoder\"}", "Returns: 18", "{\"a\",\"b\"}", "Returns: 6", "{\"a\", \"ab\", \"abac\", \"abacus\" }", "Returns: 10", "{\"pyramid\", \"sphinx\", \"sphere\", \"python\", \"serpent\"}", "Returns: 39", "{\"ba\",\"a\",\"a\",\"b\",\"ba\"}\n", "Returns: 13"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12523"},
{"titulo": "JumpFurther", "categoria": "Greedy,SimpleMath", "dificultad": "Facil", "enunciado": " Little Fox Jiro is standing at the bottom of a long flight of stairs. The bottom of the stairs has number 0, the bottommost step has number 1, the next step has number 2, and so on. The staircase is so long that Jiro is guaranteed not to reach its top.   Jiro will now perform N consecutive actions. The actions are numbered 1 through N, in order. When performing action X, Jiro chooses between two options: either he does nothing, or he jumps exactly X steps up the stairs. In other words, if Jiro starts performing action X standing on step Y, he will end it either on step Y, or on step Y+X.   For example, if N=3, Jiro will make three consecutive choices: whether or not to jump 1 step upwards, 2 steps upwards, and then 3 steps upwards.   One of the steps is broken. The number of this step is badStep. Jiro cannot jump onto this step.   You are given the ints N and badStep. Compute and return the number of the topmost step that can be reached by Jiro.   ", "pruebas": ["2", "2", "Returns: 3", "2", "1", "Returns: 2", "3", "3", "Returns: 5", "1313", "5858", "Returns: 862641", "1", "757065", "Returns: 1"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12300"},
{"titulo": "ColorfulChocolates", "categoria": "Greedy", "dificultad": "Facil", "enunciado": "Beaver Bindu has some chocolates arranged in a row. The wrapping of each chocolate has a single color. Multiple chocolates can share the same color. In this problem, each of the possible colors is represented by an uppercase letter. You are given a String chocolates. For each i, the i-th chocolate (0-based index) in the row has the color chocolates[i].   The spread of a row of chocolates is the maximum number of adjacent chocolates that all share the same color. Formally, the spread can be defined as the maximum value of (j-i+1), where i <= j and all the chocolates in the positions between i and j, inclusive, have the same color.   You are also given an int maxSwaps. Bindu can swap any two adjacent chocolates. She has decided to make at most maxSwaps such swaps.   Return the maximum spread she can obtain. ", "pruebas": ["\"ABCDCBC\"", "1", "Returns: 2", "\"ABCDCBC\"", "2", "Returns: 3", "\"ABBABABBA\"", "3", "Returns: 4", "\"ABBABABBA\"", "4", "Returns: 5", "\"QASOKZNHWNFODOQNHGQKGLIHTPJUVGKLHFZTGPDCEKSJYIWFOO\"", "77", "Returns: 5"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12137"},
{"titulo": "TomekPhone", "categoria": "Greedy,Sorting", "dificultad": "Facil", "enunciado": " Tomek thinks that smartphones are overrated. He plans to release a new cellphone with an old-school keyboard, which may require you to tap a key multiple times to type a single letter. For example, if the keyboard has two keys, one with the letters \"adef\" and the other one with the letters \"zyx\", then typing 'a' requires one keystroke, typing 'f' requires four keystrokes, typing 'y' requires two keystrokes, and so on.    Tomek has already designed the keyboard's layout. That is, he already knows the number of keys on the keyboard, and for each key he knows the maximum number of letters it may hold. He now wants to create a specific keyboard for a language that uses N different letters. He has a large body of text in this language, and he already analyzed it to find the frequencies of all N letters of its alphabet.    You are given a int[] frequencies with N elements. Each element of frequencies is the number of times one of the letters in Tomek's alphabet appears in the text he has. Each element of frequencies will be strictly positive. (I.e., each of the N letters occurs at least once in Tomek's text.)    You are also given a int[] keySize. The number of elements of keySize is the number of keys on Tomek's keyboard. Each element of keySize gives the maximal number of letters on one of the keys.    Find an assignment of letters to keys that minimizes the number of keystrokes needed to type Tomek's entire text. Return that minimum number of keystrokes. If there is not enough room on the keys and some letters of the alphabet won't fit, return -1 instead. ", "pruebas": ["{7,3,4,1}", "{2,2}", "Returns: 19", "{13,7,4,20}", "{2,1}", "Returns: -1", "{11,23,4,50,1000,7,18}", "{3,1,4}", "Returns: 1164", "{100,1000,1,10}", "{50}", "Returns: 1234", "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50}", "{10,10,10,10,10,10,10,10}", "Returns: 3353"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12296"},
{"titulo": "ICPCBalloons", "categoria": "BruteForce,Greedy", "dificultad": "Facil", "enunciado": "You are organizing a subregional ACM ICPC contest. The problemset at the contest will consist of M problems. According to an ACM ICPC tradition, when a team solves a problem, it gets awarded a balloon. To account for this, you've bought balloons of N different colors (conveniently numbered from 0 to N-1). The number of balloons of color i that you've bought is given by balloonCount[i]. Balloons come in two sizes: medium and large. All balloons of the same color have the same size. If the i-th character of balloonSize is 'M', then all balloons of color i have medium size, and if this character is 'L', then all balloons of color i have large size.  Today you've been at the meeting with the scientific committee of the contest. There, you learned that there are additional restrictions of which you were not aware. Here are those restrictions:  These are definitely bad news, since you ordered balloons pretty much arbitrarily and it's possible that you won't be able to satisfy the restrictions with the balloons you currently have. However, the good news is that scientific committee members were able to evaluate the difficulty of each problem. More exactly, they told you that the maximum number of teams that can potentially solve the i-th problem is maxAccepted[i]. The scientific committee members are very clever and experienced, so their prediction is guaranteed to come true.  Your budget is limited and balloons are expensive, so buying more of them is not an option. Fortunately, there is a very cheap balloon repaint service at your city, so you are going to use it. The service offers repainting a given balloon into any other color. This can be one of the N colors you have, as well as any color that you don't have yet. However, it is not possible to change the size of a balloon.  You are given the int[]s balloonCount, maxAccepted and the String balloonSize. Return the minimum number of balloons that have to be repainted in order to guarantee that you will be able to award balloons to the teams properly. If it is impossible to achieve the goal using any number of balloon repaintings, return -1.", "pruebas": ["{100}", "\"L\"", "{1,2,3,4,5}", "Returns: 10", "{100}", "\"M\"", "{10,20,30,40,50}", "Returns: -1", "{5,6,1,5,6,1,5,6,1}", "\"MLMMLMMLM\"", "{7,7,4,4,7,7}", "Returns: 6", "{100,100}", "\"ML\"", "{50,51,51}", "Returns: -1", "{8,5,1,4,1,1,3,1,3,3,5,4,5,6,9}", "\"MMMLLLMMLLMLMLM\"", "{3,5,3,3,5,6,4,6,4,2,3,7,1,5,2}", "Returns: 5", "{1,18,4,7,19,7,7,1,4,8,10,5,14,13,8,22,6,3,13,5,3,4,2,1,3,15,19,4,5,9,4,11,2,7,12,20,11,26,22,7,2,10,9,20,13,20,2,9,11,9}", "\"LLMLLLLMLLLLLLLLLLLLMLLLLLLLLLLMMLMLLLMLLLLLLLLMLL\"", "{44,59,29,53,16,23,13,14,29,42,13,15,66,4,47}", "Returns: 210"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12314"},
{"titulo": "StrIIRec", "categoria": "DynamicProgramming,Greedy,Search", "dificultad": "Facil", "enunciado": "For a given string S of length n an inversion is a pair of integers (i, j) such that 0 <= i < j <= n-1 and S[i] > S[j]. (That is, the character at 0-based index i is greater than the character at 0-based index j.) For example, the string \"abcab\" has 3 inversions: (1, 3), (2, 3), and (2, 4).  Given are ints n and minInv, and a String minStr. We will consider all strings that are permutations of the first n lowercase English letters. That is, these strings have length n and contain each of the first n letters exactly once. Out of these strings, return the lexicographically smallest string R with the following two properties: minInvminStr If there is no such string, return an empty String instead. ", "pruebas": ["2", "1", "\"ab\"", "Returns: \"ba\"", "9", "1", "\"efcdgab\"", "Returns: \"efcdgabhi\"", "11", "55", "\"debgikjfc\"", "Returns: \"kjihgfedcba\"", "15", "0", "\"e\"", "Returns: \"eabcdfghijklmno\"", "9", "20", "\"fcdebiha\"", "Returns: \"fcdehigba\""], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12025"},
{"titulo": "KingdomAndTrees", "categoria": "Greedy,Search", "dificultad": "Facil", "enunciado": "King Dengklek once planted N trees, conveniently numbered 0 through N-1, along the main highway in the Kingdom of Ducks. As time passed, the trees grew beautifully. Now, the height of the i-th tree is heights[i] units.  King Dengklek now thinks that the highway would be even more beautiful if the tree heights were in strictly ascending order. More specifically, in the desired configuration the height of tree i must be strictly smaller than the height of tree i+1, for all possible i. To accomplish this, King Dengklek will cast his magic spell. If he casts magic spell of level X, he can increase or decrease the height of each tree by at most X units. He cannot decrease the height of a tree into below 1 unit. Also, the new height of each tree in units must again be an integer.  Of course, a magic spell of a high level consumes a lot of energy. Return the smallest possible non-negative integer X such that King Dengklek can achieve his goal by casting his magic spell of level X.", "pruebas": ["{9, 5, 11}", "Returns: 3", "{5, 8}", "Returns: 0", "{1, 1, 1, 1, 1}", "Returns: 4", "{548, 47, 58, 250, 2012}", "Returns: 251"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11967"},
{"titulo": "PointyWizardHats", "categoria": "Geometry,Greedy,Sorting", "dificultad": "Facil", "enunciado": "The Order of All Things Pointy and Magical has commissioned the creation of some new wizard hats. A wizard hat is created by taking two cones: a decorative top cone, and a warm and fluffy bottom cone. To assemble the hat, both cones are first placed onto a table, so that their bases are horizontal and their apexes point upwards. The top cone is then lifted and placed onto the bottom cone. The base of the top cone has to remain horizontal, and the apex of the top cone must be strictly above the apex of the bottom cone.   Not every pair of cones can be used to create a wizard hat. A wizard hat is only produced if the following two criteria are both met:   You have several top cones and several bottom cones of various sizes. Each cone can be described by its height (the distance between the apex and the base) and by the radius of its base. The top cones you have are described by topHeight and topRadius: for each valid i, you have one top cone with height topHeight[i] and radius topRadius[i]. The bottom cones you have are described by bottomHeight and bottomRadius in the same way.   Your task is to determine the maximum number of wizard hats you can make using each of the available top and bottom cones at most once.", "pruebas": ["{30}", "{3}", "{3}", "{30}", "Returns: 1", "{4,4}", "{4,3}", "{5,12}", "{5,4}", "Returns: 1", "{3}", "{3}", "{1,1}", "{2,4}", "Returns: 1", "{10,10}", "{2,5}", "{2,9}", "{3,6}", "Returns: 2", "{3,4,5}", "{5,4,3}", "{3,4,5}", "{3,8,5}", "Returns: 2", "{1,2,3,4,5}", "{2,3,4,5,6}", "{2,3,4,5,6}", "{1,2,3,4,5}", "Returns: 0", "{123,214,232,323,342,343}", "{123,123,232,123,323,434}", "{545,322,123,545,777,999}", "{323,443,123,656,767,888}", "Returns: 5", "{999,999,999,10000,10000,10000}", "{10000,10000,10000,1,2,3}", "{2324,2323,234,5454,323,232}", "{1,2,3222,434,5454,23}", "Returns: 3"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11965"},
{"titulo": "Cut", "categoria": "Greedy,Simulation", "dificultad": "Facil", "enunciado": "Fox Ciel wants to eat eels as a celebration of this year's end.  Initially, Ciel has some eels of various lengths. She only likes to eat eels of length exactly 10, no more, no less. Before she eats, she may cut the eels to prepare pieces of desired length. However, she only has the time to make at most maxCuts cuts. A single cut looks as follows:   You are given a int[] eelLengths. Each element of eelLengths is the length of one of the eels Ciel has at the beginning. You are also given the int maxCuts. Return the maximum number of eels of length exactly 10 she can produce.", "pruebas": ["{13, 20, 13}", "2", "Returns: 3", "{5, 5, 5, 5}", "2", "Returns: 0", "{34, 10, 48}", "4", "Returns: 5", "{30, 50, 30, 50}", "350", "Returns: 16"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11564"},
{"titulo": "GogoXCake", "categoria": "Greedy,Simulation", "dificultad": "Facil", "enunciado": "Like all other software engineers, Gogo likes to cut and eat cake. He used a rectangular baking dish to make a cake. The dish is divided into a grid of unit square cells. Initially, all the cells contained the cake.  Gogo's friend John wanted to eat the cake. Gogo gave John a rectangular cake cutter with the following properties: usedignored When used, the cake cutter must be placed on the dish according to the following rules: used  When the cake cutter is used in the way described above, it removes the cake from all the used cells. John may have used the cake cutter multiple times, one after another.  After John went home, Gogo examined the cake that remained in the dish. He now wants to check whether John really cut the cake according to the above rules. You are given String[]s cake and cutter. The remaining cake is described by cake. More precisely, cake[i][j] is 'X' if the cell in the i-th row and j-th column of the dish still contains cake; otherwise cake[i][j] is '.' (a period). The cake cutter is described by cutter. More precisely, cutter[i][j] is '.' (a period) if the cell in the i-th row and j-th column of the cutter is used, and 'X' if the cell is ignored.  Return \"YES\" (quotes for clarity) if it is possible that John only ate the cake by using the cutter in the way described above. Return \"NO\" otherwise.", "pruebas": ["{\"X.X\"\n,\"...\"\n,\"...\"\n,\"X.X\"}", "{\".X\"\n,\"..\"\n,\"X.\"}", "Returns: \"YES\"", "{\"..XX\"\n,\"...X\"\n,\"X...\"\n,\"XX..\"}", "{\"..\"\n,\"..\"}", "Returns: \"NO\"", "{\"...X...\"}", "{\"...\"}", "Returns: \"YES\"", "{\".X.\"\n,\"X.X\"\n,\".X.\"}", "{\".\"}", "Returns: \"YES\"", "{\"XXXXXXX\"\n,\"X.....X\"\n,\"X.....X\"\n,\"X.....X\"\n,\"XXXXXXX\"}", "{\".X.\"\n,\"XXX\"\n,\".X.\"}", "Returns: \"NO\"", "{\"..\"\n,\"X.\"\n,\".X\"}", "{\"..\"\n,\".X\"\n,\"X.\"}", "Returns: \"NO\"", "{\"X..\"\n,\".XX\"\n,\".XX\"}", "{\".XX\"\n,\".XX\"\n,\"X..\"}", "Returns: \"NO\""], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11274"},
{"titulo": "DengklekMakingChains", "categoria": "Greedy", "dificultad": "Facil", "enunciado": "Mr. Dengklek lives in the Kingdom of Ducks, where humans and ducks live together in peace and harmony.     Mr. Dengklek works as a chain maker. Today, he would like to make a beautiful chain as a decoration for one of his lovely ducks. He will produce the chain from leftovers he found in his workshop. Each of the leftovers is a chain piece consisting of exactly 3 links. Each link is either clean or rusty. Different clean links may have different degrees of beauty.    You are given a String[] chains describing the leftovers. Each element of chains is a 3-character String describing one of the chain pieces. A rusty link is represented by a period ('.'), whereas a clean link is represented by a digit ('0'-'9'). The value of the digit in the clean link is the beauty of the link. For example, chains = {\".15\", \"7..\", \"532\", \"..3\"} means that Mr. Dengklek has 4 chain pieces, and only one of these (\"532\") has no rusty links.    All links have the same shape, which allows Mr. Dengklek to concatenate any two chain pieces. However, the link shape is not symmetric, therefore he may not reverse the chain pieces. E.g., in the above example he is able to produce the chain \"532.15\" or the chain \".15..37..\", but he cannot produce \"5323..\".    To produce the chain, Mr. Dengklek will follow these steps:  The beauty of the new chain is the total beauty of all the links picked in the second step. Of course, Mr. Dengklek would like to create the most beautiful chain possible.    Return the largest possible beauty a chain can have according to the above rules.", "pruebas": ["{\".15\", \"7..\", \"402\", \"..3\"}", "Returns: 19", "{\"..1\", \"7..\", \"567\", \"24.\", \"8..\", \"234\"}", "Returns: 36", "{\"...\", \"...\"}", "Returns: 0", "{\"16.\", \"9.8\", \".24\", \"52.\", \"3.1\", \"532\", \"4.4\", \"111\"}", "Returns: 28", "{\"..1\", \"3..\", \"2..\", \".7.\"}", "Returns: 7", "{\"412\", \"..7\", \".58\", \"7.8\", \"32.\", \"6..\", \"351\", \"3.9\", \"985\", \"...\", \".46\"}", "Returns: 58"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11754"},
{"titulo": "SRMCodingPhase", "categoria": "BruteForce,Greedy,Search", "dificultad": "Facil", "enunciado": "Mr. Dengklek introduced you to an online programming contest called SRM (Special Round Match)!  You are now in the coding phase of the contest. There are 3 problems in the contest. You have practiced a lot before in practice rooms, so you are sure that you can solve the first problem in skills[0] minutes, the second problem in skills[1] minutes and the third problem is skills[2] minutes.  You have exactly 75 minutes to solve the problems. Before submitting a solution to a problem, you must first open the problem. If you submit a solution to a problem t minutes after you open the problem, you will receive: pointspointspoints  In your strategy, you only submit a solution to a problem after you solve the problem. If you don't submit a solution to a problem, you will receive zero points for the problem.  It is well-known that luck plays an important role in a contest. A fortune-teller told you that you have luck points of luck. You may use these points to decrease the amount of time you need to solve the problems, in minutes. Of course, you don't have to use all the points. Each point is worth one minute per problem. So, if you initially can solve a problem in t minutes, by using x points of luck (where x is a positive integer and 0 < x < t), you can solve the problem in (t - x) minutes (it is impossible to use t or more points of luck on the problem).  Arrange your strategy in this coding phase. Return the maximum total score you can achieve in this coding phase.", "pruebas": ["{250, 500, 1000}", "{10, 25, 40}", "0", "Returns: 1310", "{300, 600, 900}", "{30, 65, 90}", "25", "Returns: 680", "{250, 550, 950}", "{10, 25, 40}", "75", "Returns: 1736", "{256, 512, 1024}", "{35, 30, 25}", "0", "Returns: 1216", "{300, 600, 1100}", "{80, 90, 100}", "4", "Returns: 0"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11381"},
{"titulo": "MissingParentheses", "categoria": "Greedy", "dificultad": "Facil", "enunciado": " Given a string of parentheses, you must turn it into a well formed string by inserting as few parentheses as possible, at any position (you cannot delete or change any of the existing parentheses).  A well formed string of parentheses is defined by the following rules:  As examples, \"(()())\", \"\" and \"(())()\" are well formed strings and \"())(\", \"()(\" and \")\" are malformed strings.  Given a String par of parentheses, return the minimum number of parentheses that need to be inserted to make it into a well formed string. ", "pruebas": ["\"(()(()\"", "Returns: 2", "\n(()", "(()", "\n   ^   ^\n", "\"()()(()\"", "Returns: 1", "\"(())(()())\"", "Returns: 0", "\"())(())((()))))()((())))()())())())()()()\"", "Returns: 7"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=10943"},
{"titulo": "DucksAlignment", "categoria": "BruteForce,Greedy", "dificultad": "Facil", "enunciado": "Mr. Dengklek has a rectangular farm conveniently divided into a grid of unit squares. At this moment, each unit square contains at most one duck. Moreover, each row and column of the farm also contains at most one duck. You are given a String[] grid. The j-th character of the i-th element of grid will be 'o' if there is exactly one duck in square (i, j), i.e., row i column j, or '.' if there is no duck in that square.   Today, Mr. Dengklek wants to align the ducks so that the ducks form a contiguous line. More precisely, assume that there are N ducks on the farm. After the alignment, the ducks must either occupy N contiguous squares in some row or N contiguous squares in some column. To accomplish that, he will move the ducks one at a time. To move a duck in square (a, b) to another empty square (c, d), he needs |a-c| + |b-d| seconds, where |x| denotes the absolute value of x. Mr. Dengklek can always move any duck to any empty square he desires - the other ducks are not obstacles.  Return the minimum time in seconds Mr. Dengklek needs to align the ducks. Note that restrictions imposed on the initial placement of ducks guarantee that a proper alignment is always possible.", "pruebas": ["{\".o\",\n \"o.\"}", "Returns: 1", "{\".o...\",\n \"..o..\",\n \"....o\"}", "Returns: 3", "{\"o..........\",\n \"..o........\",\n \".......o...\",\n \"...........\",\n \"...........\",\n \"...........\",\n \"........o..\",\n \"...........\"}", "Returns: 16", "{\".........\",\n \"....o....\",\n \".........\"}", "Returns: 0", "{\"...o..........................\",\n \"............................o.\",\n \".o............................\",\n \"............o.................\",\n \".................o............\",\n \"......................o.......\",\n \"......o.......................\",\n \"....o.........................\",\n \"...............o..............\",\n \".......................o......\",\n \"...........................o..\",\n \".......o......................\"}", "Returns: 99"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11667"}
]