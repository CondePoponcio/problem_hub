[
{"titulo": "TheKingsFactorization", "categoria": "BruteForce,Greedy,Math", "dificultad": "Facil", "enunciado": " The King of Byteland likes integer factorization. Your task is to help him factor the number N. You will be given the long N and you should return a long[] containing all prime factors of N sorted in non-decreasing order. Note that some primes may occur multiple times in the prime factorization of N. For example, for N = 60 the only correct return value is {2, 2, 3, 5} because 2*2*3*5 = 60.     To make this task easier, the King has decided to give you a hint. He already knows the correct factorization and he will tell you every second number in the correct return value. More precisely, in addition to N you will be given a long[] primes. The number of elements in primes will be (M+1)/2, rounded down, where M is the number of elements in the correct return value. For each valid i, primes[i] will be equal to the element 2i of the correct return value. (All indices are 0-based.)     Given N and primes, return the long[] containing the factorization of N. ", "pruebas": ["12", "{2, 3}", "Returns: {2, 2, 3 }", "7", "{7}", "Returns: {7 }", "1764", "{2, 3, 7}", "Returns: {2, 2, 3, 3, 7, 7 }", "49", "{7}", "Returns: {7, 7 }", "210", "{2, 5}", "Returns: {2, 3, 5, 7 }", "100000", "{2, 2, 2, 5, 5}", "Returns: {2, 2, 2, 2, 2, 5, 5, 5, 5, 5 }"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=13594"},
{"titulo": "StrIIRec", "categoria": "DynamicProgramming,Greedy,Search", "dificultad": "Facil", "enunciado": "For a given string S of length n an inversion is a pair of integers (i, j) such that 0 <= i < j <= n-1 and S[i] > S[j]. (That is, the character at 0-based index i is greater than the character at 0-based index j.) For example, the string \"abcab\" has 3 inversions: (1, 3), (2, 3), and (2, 4).  Given are ints n and minInv, and a String minStr. We will consider all strings that are permutations of the first n lowercase English letters. That is, these strings have length n and contain each of the first n letters exactly once. Out of these strings, return the lexicographically smallest string R with the following two properties: minInvminStr If there is no such string, return an empty String instead. ", "pruebas": ["2", "1", "\"ab\"", "Returns: \"ba\"", "9", "1", "\"efcdgab\"", "Returns: \"efcdgabhi\"", "11", "55", "\"debgikjfc\"", "Returns: \"kjihgfedcba\"", "15", "0", "\"e\"", "Returns: \"eabcdfghijklmno\"", "9", "20", "\"fcdebiha\"", "Returns: \"fcdehigba\""], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12025"},
{"titulo": "KingdomAndTrees", "categoria": "Greedy,Search", "dificultad": "Facil", "enunciado": "King Dengklek once planted N trees, conveniently numbered 0 through N-1, along the main highway in the Kingdom of Ducks. As time passed, the trees grew beautifully. Now, the height of the i-th tree is heights[i] units.  King Dengklek now thinks that the highway would be even more beautiful if the tree heights were in strictly ascending order. More specifically, in the desired configuration the height of tree i must be strictly smaller than the height of tree i+1, for all possible i. To accomplish this, King Dengklek will cast his magic spell. If he casts magic spell of level X, he can increase or decrease the height of each tree by at most X units. He cannot decrease the height of a tree into below 1 unit. Also, the new height of each tree in units must again be an integer.  Of course, a magic spell of a high level consumes a lot of energy. Return the smallest possible non-negative integer X such that King Dengklek can achieve his goal by casting his magic spell of level X.", "pruebas": ["{9, 5, 11}", "Returns: 3", "{5, 8}", "Returns: 0", "{1, 1, 1, 1, 1}", "Returns: 4", "{548, 47, 58, 250, 2012}", "Returns: 251"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11967"},
{"titulo": "PointyWizardHats", "categoria": "Geometry,Greedy,Sorting", "dificultad": "Facil", "enunciado": "The Order of All Things Pointy and Magical has commissioned the creation of some new wizard hats. A wizard hat is created by taking two cones: a decorative top cone, and a warm and fluffy bottom cone. To assemble the hat, both cones are first placed onto a table, so that their bases are horizontal and their apexes point upwards. The top cone is then lifted and placed onto the bottom cone. The base of the top cone has to remain horizontal, and the apex of the top cone must be strictly above the apex of the bottom cone.   Not every pair of cones can be used to create a wizard hat. A wizard hat is only produced if the following two criteria are both met:   You have several top cones and several bottom cones of various sizes. Each cone can be described by its height (the distance between the apex and the base) and by the radius of its base. The top cones you have are described by topHeight and topRadius: for each valid i, you have one top cone with height topHeight[i] and radius topRadius[i]. The bottom cones you have are described by bottomHeight and bottomRadius in the same way.   Your task is to determine the maximum number of wizard hats you can make using each of the available top and bottom cones at most once.", "pruebas": ["{30}", "{3}", "{3}", "{30}", "Returns: 1", "{4,4}", "{4,3}", "{5,12}", "{5,4}", "Returns: 1", "{3}", "{3}", "{1,1}", "{2,4}", "Returns: 1", "{10,10}", "{2,5}", "{2,9}", "{3,6}", "Returns: 2", "{3,4,5}", "{5,4,3}", "{3,4,5}", "{3,8,5}", "Returns: 2", "{1,2,3,4,5}", "{2,3,4,5,6}", "{2,3,4,5,6}", "{1,2,3,4,5}", "Returns: 0", "{123,214,232,323,342,343}", "{123,123,232,123,323,434}", "{545,322,123,545,777,999}", "{323,443,123,656,767,888}", "Returns: 5", "{999,999,999,10000,10000,10000}", "{10000,10000,10000,1,2,3}", "{2324,2323,234,5454,323,232}", "{1,2,3222,434,5454,23}", "Returns: 3"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11965"},
{"titulo": "ColorfulChocolates", "categoria": "Greedy", "dificultad": "Facil", "enunciado": "Beaver Bindu has some chocolates arranged in a row. The wrapping of each chocolate has a single color. Multiple chocolates can share the same color. In this problem, each of the possible colors is represented by an uppercase letter. You are given a String chocolates. For each i, the i-th chocolate (0-based index) in the row has the color chocolates[i].   The spread of a row of chocolates is the maximum number of adjacent chocolates that all share the same color. Formally, the spread can be defined as the maximum value of (j-i+1), where i <= j and all the chocolates in the positions between i and j, inclusive, have the same color.   You are also given an int maxSwaps. Bindu can swap any two adjacent chocolates. She has decided to make at most maxSwaps such swaps.   Return the maximum spread she can obtain. ", "pruebas": ["\"ABCDCBC\"", "1", "Returns: 2", "\"ABCDCBC\"", "2", "Returns: 3", "\"ABBABABBA\"", "3", "Returns: 4", "\"ABBABABBA\"", "4", "Returns: 5", "\"QASOKZNHWNFODOQNHGQKGLIHTPJUVGKLHFZTGPDCEKSJYIWFOO\"", "77", "Returns: 5"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12137"},
{"titulo": "TomekPhone", "categoria": "Greedy,Sorting", "dificultad": "Facil", "enunciado": " Tomek thinks that smartphones are overrated. He plans to release a new cellphone with an old-school keyboard, which may require you to tap a key multiple times to type a single letter. For example, if the keyboard has two keys, one with the letters \"adef\" and the other one with the letters \"zyx\", then typing 'a' requires one keystroke, typing 'f' requires four keystrokes, typing 'y' requires two keystrokes, and so on.    Tomek has already designed the keyboard's layout. That is, he already knows the number of keys on the keyboard, and for each key he knows the maximum number of letters it may hold. He now wants to create a specific keyboard for a language that uses N different letters. He has a large body of text in this language, and he already analyzed it to find the frequencies of all N letters of its alphabet.    You are given a int[] frequencies with N elements. Each element of frequencies is the number of times one of the letters in Tomek's alphabet appears in the text he has. Each element of frequencies will be strictly positive. (I.e., each of the N letters occurs at least once in Tomek's text.)    You are also given a int[] keySize. The number of elements of keySize is the number of keys on Tomek's keyboard. Each element of keySize gives the maximal number of letters on one of the keys.    Find an assignment of letters to keys that minimizes the number of keystrokes needed to type Tomek's entire text. Return that minimum number of keystrokes. If there is not enough room on the keys and some letters of the alphabet won't fit, return -1 instead. ", "pruebas": ["{7,3,4,1}", "{2,2}", "Returns: 19", "{13,7,4,20}", "{2,1}", "Returns: -1", "{11,23,4,50,1000,7,18}", "{3,1,4}", "Returns: 1164", "{100,1000,1,10}", "{50}", "Returns: 1234", "{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50}", "{10,10,10,10,10,10,10,10}", "Returns: 3353"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12296"},
{"titulo": "ICPCBalloons", "categoria": "BruteForce,Greedy", "dificultad": "Facil", "enunciado": "You are organizing a subregional ACM ICPC contest. The problemset at the contest will consist of M problems. According to an ACM ICPC tradition, when a team solves a problem, it gets awarded a balloon. To account for this, you've bought balloons of N different colors (conveniently numbered from 0 to N-1). The number of balloons of color i that you've bought is given by balloonCount[i]. Balloons come in two sizes: medium and large. All balloons of the same color have the same size. If the i-th character of balloonSize is 'M', then all balloons of color i have medium size, and if this character is 'L', then all balloons of color i have large size.  Today you've been at the meeting with the scientific committee of the contest. There, you learned that there are additional restrictions of which you were not aware. Here are those restrictions:  These are definitely bad news, since you ordered balloons pretty much arbitrarily and it's possible that you won't be able to satisfy the restrictions with the balloons you currently have. However, the good news is that scientific committee members were able to evaluate the difficulty of each problem. More exactly, they told you that the maximum number of teams that can potentially solve the i-th problem is maxAccepted[i]. The scientific committee members are very clever and experienced, so their prediction is guaranteed to come true.  Your budget is limited and balloons are expensive, so buying more of them is not an option. Fortunately, there is a very cheap balloon repaint service at your city, so you are going to use it. The service offers repainting a given balloon into any other color. This can be one of the N colors you have, as well as any color that you don't have yet. However, it is not possible to change the size of a balloon.  You are given the int[]s balloonCount, maxAccepted and the String balloonSize. Return the minimum number of balloons that have to be repainted in order to guarantee that you will be able to award balloons to the teams properly. If it is impossible to achieve the goal using any number of balloon repaintings, return -1.", "pruebas": ["{100}", "\"L\"", "{1,2,3,4,5}", "Returns: 10", "{100}", "\"M\"", "{10,20,30,40,50}", "Returns: -1", "{5,6,1,5,6,1,5,6,1}", "\"MLMMLMMLM\"", "{7,7,4,4,7,7}", "Returns: 6", "{100,100}", "\"ML\"", "{50,51,51}", "Returns: -1", "{8,5,1,4,1,1,3,1,3,3,5,4,5,6,9}", "\"MMMLLLMMLLMLMLM\"", "{3,5,3,3,5,6,4,6,4,2,3,7,1,5,2}", "Returns: 5", "{1,18,4,7,19,7,7,1,4,8,10,5,14,13,8,22,6,3,13,5,3,4,2,1,3,15,19,4,5,9,4,11,2,7,12,20,11,26,22,7,2,10,9,20,13,20,2,9,11,9}", "\"LLMLLLLMLLLLLLLLLLLLMLLLLLLLLLLMMLMLLLMLLLLLLLLMLL\"", "{44,59,29,53,16,23,13,14,29,42,13,15,66,4,47}", "Returns: 210"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12314"},
{"titulo": "BallsSeparating", "categoria": "BruteForce,Greedy", "dificultad": "Facil", "enunciado": "There are N boxes numbered from 0 to N-1, inclusive. For each i, box i contains red[i] red balls, green[i] green balls, and blue[i] blue balls.   Fox Ciel wants to separate the balls by colors. In each operation, she can pick a single ball from some box and put it into another box. She considers the balls to be separated if no box contains balls of more than one color.   Return the minimal number of operations required to separate the balls. If this is impossible, return -1. ", "pruebas": ["{1, 1, 1}", "{1, 1, 1}", "{1, 1, 1}", "Returns: 6", "{5}", "{6}", "{8}", "Returns: -1", "{4, 6, 5, 7}", "{7, 4, 6, 3}", "{6, 5, 3, 8}", "Returns: 37", "{7, 12, 9, 9, 7}", "{7, 10, 8, 8, 9}", "{8, 9, 5, 6, 13}", "Returns: 77", "{842398, 491273, 958925, 849859, 771363, 67803, 184892, 391907, 256150, 75799}", "{268944, 342402, 894352, 228640, 903885, 908656, 414271, 292588, 852057, 889141}", "{662939, 340220, 600081, 390298, 376707, 372199, 435097, 40266, 145590, 505103}", "Returns: 7230607"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12398"},
{"titulo": "UndoHistory", "categoria": "Greedy,SimpleSearch,Iteration", "dificultad": "Facil", "enunciado": "Bob is using a peculiar text editor to write a sequence of lines of text. The editor consists of three parts: a results window, a text buffer and an undo history. More details about the three parts follow.   You are given a String[] lines. Bob would like to print the contents of lines into the results window. (At the end, the sequence of strings stored in the results window must be precisely equal to lines. Order of elements matters.) Additionally, Bob would like to do so as quickly as possible. He is able to take the following actions:    Return the minimum total number of button presses (keyboard and mouse) that Bob needs to print all the given lines into the results window.", "pruebas": ["{\"tomorrow\", \"topcoder\"}", "Returns: 18", "{\"a\",\"b\"}", "Returns: 6", "{\"a\", \"ab\", \"abac\", \"abacus\" }", "Returns: 10", "{\"pyramid\", \"sphinx\", \"sphere\", \"python\", \"serpent\"}", "Returns: 39", "{\"ba\",\"a\",\"a\",\"b\",\"ba\"}\n", "Returns: 13"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12523"},
{"titulo": "JumpFurther", "categoria": "Greedy,SimpleMath", "dificultad": "Facil", "enunciado": " Little Fox Jiro is standing at the bottom of a long flight of stairs. The bottom of the stairs has number 0, the bottommost step has number 1, the next step has number 2, and so on. The staircase is so long that Jiro is guaranteed not to reach its top.   Jiro will now perform N consecutive actions. The actions are numbered 1 through N, in order. When performing action X, Jiro chooses between two options: either he does nothing, or he jumps exactly X steps up the stairs. In other words, if Jiro starts performing action X standing on step Y, he will end it either on step Y, or on step Y+X.   For example, if N=3, Jiro will make three consecutive choices: whether or not to jump 1 step upwards, 2 steps upwards, and then 3 steps upwards.   One of the steps is broken. The number of this step is badStep. Jiro cannot jump onto this step.   You are given the ints N and badStep. Compute and return the number of the topmost step that can be reached by Jiro.   ", "pruebas": ["2", "2", "Returns: 3", "2", "1", "Returns: 2", "3", "3", "Returns: 5", "1313", "5858", "Returns: 862641", "1", "757065", "Returns: 1"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=12300"},
{"titulo": "MysteriousRestaurant", "categoria": "BruteForce,Greedy", "dificultad": "Facil", "enunciado": "A mysterious new restaurant is open in the city for only N days. Happy to hear that, Ash and Elsh would like to have lunch at the restaurant on as many days as possible.  The restaurant sells M types of dishes. Being a mysterious restaurant, it has mysterious rules for the customers:    Mysteriously, the price of each type of dish varies every day. You are given a String[] prices consisting of N elements, each containing M characters. prices[i][j] represents the price of the j-th type of dish on the i-th day, encoded as follows:    Ash and Elsh have only budget dollars allocated for having lunch in the restaurant. Return the maximum number of days they could have lunch in the restaurant.", "pruebas": ["{\"26\", \"14\", \"72\", \"39\", \"32\", \"85\", \"06\"}", "13", "Returns: 5", "{\"26\", \"14\", \"72\", \"39\", \"32\", \"85\", \"06\", \"91\"}", "20", "Returns: 8", "{\"SRM\", \"512\"}", "4", "Returns: 0", "{\"Dear\", \"Code\", \"rsHa\", \"veFu\", \"nInT\", \"heCh\", \"alle\", \"ngeP\", \"hase\", \"andb\", \"ecar\", \"eful\"}", "256", "Returns: 10"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11295"},
{"titulo": "NetworkXOneTimePad", "categoria": "BruteForce,Encryption/Compression,Greedy", "dificultad": "Facil", "enunciado": "One-time pad (patented by Vernam in 1919) is one of the most widely known schemes to encrypt a binary string to achieve confidentiality. This scheme takes a binary string (a string consisting of only the digits 0 and 1) as input and outputs another binary string of the same length. The input is called the plaintext, and the output is called the ciphertext. The scheme uses a key which is another binary string of the same length as the input. The i-th bit of the ciphertext is defined as the XOR of the i-th bit of the plaintext and the key (see the notes for XOR definition). The ciphertext is sent to the receiving party.  In this problem, we will consider several messages, each of length N, encrypted using a single key of length N.   We would like to investigate how strong this cipher is. Suppose an adversary manages to find out the content of all the original messages (i.e., the plaintexts) and some of the encrypted messages (i.e., ciphertexts). These messages are given in the String[]s plaintexts and ciphertexts, respectively. Return the number of possible keys that are consistent with this data. The constraints will guarantee that there is at least one such key. A key is consistent if for all members of ciphertexts C, there exists a member of plaintexts P such that when P is encrypted using the specified key, it becomes C.", "pruebas": ["{\"110\", \"001\"}", "{\"101\", \"010\"}", "Returns: 2", "{\"00\", \"01\", \"10\", \"11\"}", "{\"00\", \"01\", \"10\", \"11\"}", "Returns: 4", "{\"01\", \"10\"}", "{\"00\"}", "Returns: 2", "{\"000\", \"111\", \"010\", \"101\", \"110\", \"001\"}", "{\"011\", \"100\"}", "Returns: 6"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=10846"},
{"titulo": "LargestSubsequence", "categoria": "Greedy,StringManipulation", "dificultad": "Facil", "enunciado": " For Strings x and y, we say y is a subsequence of x if y can be obtained from x by erasing some (possibly all or none) of the letters in x. For example, \"tpcdr\" is a subsequence of \"topcoder\", while \"rt\" is not.   Given a String s, return the lexicographically largest subsequence of s.  ", "pruebas": ["\"test\"", "Returns: \"tt\"", "\"a\"", "Returns: \"a\"", "\"example\"", "Returns: \"xple\"", "\"aquickbrownfoxjumpsoverthelazydog\"", "Returns: \"zyog\""], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11471"},
{"titulo": "SRMCodingPhase", "categoria": "BruteForce,Greedy,Search", "dificultad": "Facil", "enunciado": "Mr. Dengklek introduced you to an online programming contest called SRM (Special Round Match)!  You are now in the coding phase of the contest. There are 3 problems in the contest. You have practiced a lot before in practice rooms, so you are sure that you can solve the first problem in skills[0] minutes, the second problem in skills[1] minutes and the third problem is skills[2] minutes.  You have exactly 75 minutes to solve the problems. Before submitting a solution to a problem, you must first open the problem. If you submit a solution to a problem t minutes after you open the problem, you will receive: pointspointspoints  In your strategy, you only submit a solution to a problem after you solve the problem. If you don't submit a solution to a problem, you will receive zero points for the problem.  It is well-known that luck plays an important role in a contest. A fortune-teller told you that you have luck points of luck. You may use these points to decrease the amount of time you need to solve the problems, in minutes. Of course, you don't have to use all the points. Each point is worth one minute per problem. So, if you initially can solve a problem in t minutes, by using x points of luck (where x is a positive integer and 0 < x < t), you can solve the problem in (t - x) minutes (it is impossible to use t or more points of luck on the problem).  Arrange your strategy in this coding phase. Return the maximum total score you can achieve in this coding phase.", "pruebas": ["{250, 500, 1000}", "{10, 25, 40}", "0", "Returns: 1310", "{300, 600, 900}", "{30, 65, 90}", "25", "Returns: 680", "{250, 550, 950}", "{10, 25, 40}", "75", "Returns: 1736", "{256, 512, 1024}", "{35, 30, 25}", "0", "Returns: 1216", "{300, 600, 1100}", "{80, 90, 100}", "4", "Returns: 0"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11381"},
{"titulo": "MissingParentheses", "categoria": "Greedy", "dificultad": "Facil", "enunciado": " Given a string of parentheses, you must turn it into a well formed string by inserting as few parentheses as possible, at any position (you cannot delete or change any of the existing parentheses).  A well formed string of parentheses is defined by the following rules:  As examples, \"(()())\", \"\" and \"(())()\" are well formed strings and \"())(\", \"()(\" and \")\" are malformed strings.  Given a String par of parentheses, return the minimum number of parentheses that need to be inserted to make it into a well formed string. ", "pruebas": ["\"(()(()\"", "Returns: 2", "\n(()", "(()", "\n   ^   ^\n", "\"()()(()\"", "Returns: 1", "\"(())(()())\"", "Returns: 0", "\"())(())((()))))()((())))()())())())()()()\"", "Returns: 7"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=10943"},
{"titulo": "DucksAlignment", "categoria": "BruteForce,Greedy", "dificultad": "Facil", "enunciado": "Mr. Dengklek has a rectangular farm conveniently divided into a grid of unit squares. At this moment, each unit square contains at most one duck. Moreover, each row and column of the farm also contains at most one duck. You are given a String[] grid. The j-th character of the i-th element of grid will be 'o' if there is exactly one duck in square (i, j), i.e., row i column j, or '.' if there is no duck in that square.   Today, Mr. Dengklek wants to align the ducks so that the ducks form a contiguous line. More precisely, assume that there are N ducks on the farm. After the alignment, the ducks must either occupy N contiguous squares in some row or N contiguous squares in some column. To accomplish that, he will move the ducks one at a time. To move a duck in square (a, b) to another empty square (c, d), he needs |a-c| + |b-d| seconds, where |x| denotes the absolute value of x. Mr. Dengklek can always move any duck to any empty square he desires - the other ducks are not obstacles.  Return the minimum time in seconds Mr. Dengklek needs to align the ducks. Note that restrictions imposed on the initial placement of ducks guarantee that a proper alignment is always possible.", "pruebas": ["{\".o\",\n \"o.\"}", "Returns: 1", "{\".o...\",\n \"..o..\",\n \"....o\"}", "Returns: 3", "{\"o..........\",\n \"..o........\",\n \".......o...\",\n \"...........\",\n \"...........\",\n \"...........\",\n \"........o..\",\n \"...........\"}", "Returns: 16", "{\".........\",\n \"....o....\",\n \".........\"}", "Returns: 0", "{\"...o..........................\",\n \"............................o.\",\n \".o............................\",\n \"............o.................\",\n \".................o............\",\n \"......................o.......\",\n \"......o.......................\",\n \"....o.........................\",\n \"...............o..............\",\n \".......................o......\",\n \"...........................o..\",\n \".......o......................\"}", "Returns: 99"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11667"},
{"titulo": "ScoreRecomposition", "categoria": "Greedy,SimpleSearch,Iteration", "dificultad": "Facil", "enunciado": "You took a test consisting of N questions, each of which has a distinct point value between 1 and N, inclusive, and you have finally received the results.  Along with your final score, you are told which questions you answered correctly.  However, you are not given the point values that were assigned to the questions.  For each correct answer, you received the full point value of the question, and for each wrong answer, you received 0 points.  You must determine the minimum possible error of a valid point assignment that would result in the final score that you received.  The error of a valid assignment of points is defined as follows: For each question i (where i is a 1-based index), let e(i) = the absolute value of (i minus the point value of the question).  The error of the point assignment is the maximum value of e(i).  Given a String questions and an int score, return an int representing the minimum possible error of a valid point assignment.  The ith character (where i is a 1-based index) of questions is either 'C', meaning that you answered question i correctly, or 'W', meaning that you answered it wrong.  If there is no valid point assignment, return -1.", "pruebas": ["\"CCC\"", "5", "Returns: -1", "\"WCWW\"", "4", "Returns: 2", "\"CWW\"", "1", "Returns: 0", "\"CWCC\"", "6", "Returns: 2", "\"WWCC\"", "3", "Returns: 2", "\"CWCCWWCWCC\"", "55", "Returns: -1", "\"CWWCWCCWWC\"", "37", "Returns: 3"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6241"},
{"titulo": "FanFailure", "categoria": "Greedy", "dificultad": "Facil", "enunciado": " In a robust computer system, one of the most important pieces is the cooling.  Without proper cooling, processors can heat up to over 400 degrees C.  The reliability of a system can be measured by determining how many fans can fail without risking the system processor.  Each fan can be assigned a value indicating how much capacity it has to cool the system, and we can define a minimum cooling capacity, which the sum of the fan capacities must exceed to properly cool the system.  We define a Failure Set as a set of fans which are not necessary to cool the system.  In other words, if the fans in a Failure Set break, the system can still be properly cooled by the remaining fans.  The count of a Failure Set is the number of fans in the set.    To measure the reliability, we will define two values, the Maximum Failure Set (MFS) and the Maximum Failure Count (MFC).  A MFS is a Failure Set of fans with the largest count possible.  A set of fans may have more than one MFS (see below).  A Failure Set is an MFS if and only if there are no Failure Sets with a higher count.  The MFC is the largest value such that all fan sets with count <= MFC are Failure Sets.  In other words, any set of fans of size MFC or less can fail, and the system will still be properly cooled by the remaining fans.    Consider the fan set with capacities 1, 2, 3, and a cooling requirement of 2.  Two MFSs with a count of 2 exist: fans 1 and 3, or fans 1 and 2.  However, the MFC is not 2 because fans 2 and 3 is not a Failure set (fan 1 could not cool the system properly by itself).  Thus, the MFC is 1, because if any single fan fails, the system can still be cooled.    You will be given a int[] capacities, which designates how many units of cooling each fan provides, and an int minCooling, which designates the minimum units of cooling required to cool the system.  Your method should return a int[], where the first value should be the number of fans in the Maximum Failure Set (MFS), and the second value should be the Maximum Failure Count (MFC). ", "pruebas": ["{1,2,3}", "2", "Returns: { 2,  1 }", "{8,5,6,7}", "22", "Returns: { 0,  0 }", "{676, 11, 223, 413, 823, 122, 547, 187, 28}", "1000", "Returns: { 7,  2 }", "{955, 96, 161, 259, 642, 242, 772, 369, 311, 785,\n 92, 991, 620, 394, 128, 774, 973, 94, 681, 771,\n 916, 373, 523, 100, 220, 993, 472, 798, 132, 361,\n 33, 362, 573, 624, 722, 520, 451, 231, 37, 921,\n 408, 170, 303, 559, 866, 412, 339, 757, 822, 192}", "3619", "Returns: { 46,  30 }"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=2235"},
{"titulo": "RockStar", "categoria": "Greedy", "dificultad": "Facil", "enunciado": "Inspired by the Dire Straits song, \"Money for Nothing\", you have decided to become a rock star. After a lengthy recording session, you have acquired: fffssfss It remains only to determine which of these songs should go on your first album, and in what order they should appear. Of course, no song can appear on the album more than once.  Unfortunately, your record company has placed several restrictions on your album:  At this stage in your artistic career, you must do what your record company has ordered, but you do want to place as many songs as possible on the album.  Given ints ff, fs, sf, and ss, representing the quantities described above, return the maximum number of songs that can be placed on a single album without violating the record company's restrictions. ", "pruebas": ["100", "0", "0", "200", "Returns: 100", "0", "0", "20", "200", "Returns: 201", "1", "2", "1", "1", "Returns: 5", "192", "279", "971", "249", "Returns: 999"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=2984"},
{"titulo": "PlayGame", "categoria": "BruteForce,Greedy,SimpleMath", "dificultad": "Facil", "enunciado": "You are playing a computer game and a big fight is planned between two armies.  You and your computer opponent will line up your respective units in two rows, with each of your units facing exactly one of your opponent's units and vice versa. Then, each pair of units, who face each other will fight and the stronger one will be victorious, while the weaker one will be captured. If two opposing units are equally strong, your unit will lose and be captured. You know how the computer will arrange its units, and must decide how to line up yours. You want to maximize the sum of the strengths of your units that are not captured during the battle.  You will be given a int[] you and a int[] computer that specify the strengths of the units that you and the computer have, respectively. The return value should be an int, the maximum total strength of your units that are not captured.", "pruebas": ["{5, 15, 100, 1, 5}", "{5, 15, 100, 1, 5}", "Returns: 120", "{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, \n 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,\n 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,\n 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,\n 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000}", "{1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, \n 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,\n 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,\n 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000,\n 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000}", "Returns: 0", "{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}", "{2, 4, 6, 8, 10, 12, 14, 16, 18, 20}", "Returns: 99", "{2, 3, 4, 5, 6, 7, 8, 9, 10, 11}", "{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}", "Returns: 65", "{651, 321, 106, 503, 227, 290, 915, 549, 660, 115,\n 491, 378, 495, 789, 507, 381, 685, 530, 603, 394,\n 7, 704, 101, 620, 859, 490, 744, 495, 379, 781,\n 550, 356, 950, 628, 177, 373, 132, 740, 946, 609,\n 29, 329, 57, 636, 132, 843, 860, 594, 718, 849}", "{16, 127, 704, 614, 218, 67, 169, 621, 340, 319,\n 366, 658, 798, 803, 524, 608, 794, 896, 145, 627,\n 401, 253, 137, 851, 67, 426, 571, 302, 546, 225,\n 311, 111, 804, 135, 284, 784, 890, 786, 740, 612,\n 360, 852, 228, 859, 229, 249, 540, 979, 55, 82}", "Returns: 25084"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=3002"},
{"titulo": "GroceryBagger", "categoria": "Greedy,SimpleSearch,Iteration,Sorting", "dificultad": "Facil", "enunciado": "You have just begun working as a grocery bagger at the local TopGrocer food store.  Your job is to place all of a customer's items into bags, so they can be carried from the store.  Your manager has instructed you to use as few bags as possible, to minimize the store's overall cost.  However, for the customer's convenience, you are instructed that only items of the same type can be placed in the same bag.  For instance, a produce item can be bagged with any other produce items, but not with dairy items.  You are given a String[] itemType indicating the type of each item that needs to be bagged.  You are also given an int strength indicating the maximum number of items that can be placed in each bag.  You are to return an int indicating the minimum number of bags required to package the customer's items. ", "pruebas": ["2", "{\"DAIRY\",\n \"DAIRY\",\n \"PRODUCE\",\n \"PRODUCE\",\n \"PRODUCE\",\n \"MEAT\"}", "Returns: 4", "3", "{\"DAIRY\",\n \"DAIRY\",\n \"PRODUCE\",\n \"PRODUCE\",\n \"PRODUCE\",\n \"MEAT\"}", "Returns: 3", "10", "{}", "Returns: 0", "5", "{\"CANNED\",   \"CANNED\",  \"PRODUCE\",\n \"DAIRY\",    \"MEAT\",    \"BREAD\",\n \"HOUSEHOLD\",\"PRODUCE\", \"FROZEN\",\n \"PRODUCE\", \"DAIRY\"}", "Returns: 7", "2", "{\"CANNED\",   \"CANNED\",  \"PRODUCE\",\n \"DAIRY\",    \"MEAT\",    \"BREAD\",\n \"HOUSEHOLD\",\"PRODUCE\", \"FROZEN\",\n \"PRODUCE\", \"DAIRY\"}", "Returns: 8"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=3450"},
{"titulo": "OptimalQueues", "categoria": "Greedy", "dificultad": "Facil", "enunciado": " It is the beginning of the day at a bank, and a crowd of clients is already waiting for the entrance door to open. Once the bank opens, no more clients arrive, and tellerCount tellers begin serving the clients. A teller takes serviceTime minutes to serve each client. clientArrivals specifies how long each client has already been waiting at the moment when the bank door opens. Your program should determine the best way to arrange the clients into tellerCount queues, so that the waiting time of the client who waits longest is minimized. The waiting time of a client is the sum of the time the client waited outside before the bank opened, the time the client waited in a queue once the bank opened until the service began, and the service time of the client.   Return the minimum waiting time for the client who waits the longest.  ", "pruebas": ["{1,2}", "1", "10", "Returns: 21", "{10}", "50", "50", "Returns: 60", "{10,10,10}", "2", "20", "Returns: 50", "{2,4,6,3,5}", "3", "10", "Returns: 23"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6169"},
{"titulo": "IndicatorMotionReverse", "categoria": "Greedy,Simulation", "dificultad": "Facil", "enunciado": "The first thing you have to do is to concatenate all elements of actions into one long string, and that will be your input string. In this problem, you will write a program that controls the actions of a progress indicator. The indicator is a single bar character in the middle of the screen with one of 4 states: '|', '/', '-', and '\\'. From now on, we will refer to '\\' as 'N', for programming convenience. The program is a sequence of instructions in the form: <instr> <secs> where <instr> represents one of 4 possible actions, and <secs> is the action's duration in seconds. The action is performed once each second. The 4 possible actions are: So, the sequence \"F03L02\" and the starting state of '-' leads to the following sequence: \"-|-|N-\". Given a String[] actions representing a sequence of actions, return the shortest program that leads to that sequence. The first character of the sequence is the starting state, so your program should run for K-1 seconds where K is the length of the given sequence. If there are multiple shortest programs that produce the given sequence, return the lexicographically first among them. If the return string has more than 100 characters, return only the first 97 followed by \"...\" (see last example for clarification).", "pruebas": ["{\"-|-|/-/|//////-/\"}", "Returns: \"F03R02L02R01S05R01L01\"", "\n-|-|/-/|//////-/\n.FFFRRLLRSSSSSRL\n", "{\"N\"}", "Returns: \"\"", "{\"||||||||||||||||||||||||||||||||||||||||||||||||||\",\n \"||||||||||||||||||||||||||||||||||||||||||||||||||\",\n \"||||||||||||||||||||||||||||||||||||||||||||||||||\"}", "Returns: \"S50S99\"", "{\"N\",\n \"-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N\",\n \"-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N\",\n \"-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N\",\n \"-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N\",\n \"-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N\",\n \"-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N\",\n \"-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N\",\n \"-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N-N\"}", "Returns: \n\"L01R01L01R01L01R01L01R01L01R01L01R01L01R01L01R01L01R01L01R01L01R01L01R01L01R01L01R01L01R01L01R01L...\""], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6172"},
{"titulo": "BifidSortMachine", "categoria": "Greedy,SimpleSearch,Iteration,Sorting", "dificultad": "Facil", "enunciado": "We have a sorting machine that works on a list of distinct numbers.  This machine only has two instructions, named  and .  Each instruction takes one element of the list as a parameter and removes that element from the list.   will then append that element to the end of the remaining list, while  will insert it at the beginning. For example, the sequence {8,12,25,7,15,19} can be sorted in ascending order using 2 instructions: , to get {7,8,12,25,15,19} , to get {7,8,12,15,19,25} You will be given a int[] a containing a list of distinct numbers.  Return the minimum number of instructions required to sort the list in ascending order.", "pruebas": ["{8,12,25,7,15,19}", "Returns: 2", "{1,2,3,4,5}", "Returns: 0", "{1000,-1000,0}", "Returns: 1", "{1, -10, -1, -8, 4}", "Returns: 3"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6415"},
{"titulo": "PartSorting", "categoria": "Greedy,Sorting", "dificultad": "Facil", "enunciado": "You are given a int[] data. All elements in data are distinct. Only consecutive pairs of elements in data can be swapped.  You are allowed to perform at most nSwaps swaps. Return the lexicographically maximal possible result. ", "pruebas": ["{10, 20, 30, 40, 50, 60, 70}", "1", "Returns: {20, 10, 30, 40, 50, 60, 70 }", "{3, 5, 1, 2, 4}\n", "2", "Returns: {5, 3, 2, 1, 4 }", "{19, 20, 17, 18, 15, 16, 13, 14, 11, 12}", "5", "Returns: {20, 19, 18, 17, 16, 15, 14, 13, 12, 11 }"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6447"},
{"titulo": "StandInLine", "categoria": "Greedy,SimpleMath", "dificultad": "Facil", "enunciado": "Soldiers at the Byterland South Border are ordered to stand in line each morning.  They always choose their positions randomly to the displeasure of their general.  One evening, the soldiers learn that their strict general has secretly recorded their standing positions from that morning, and that he will be checking their positions the next morning to make sure they are exactly the same. Each soldier only remembers one thing from that morning: the number of people to his left that were taller than him.  There are n soldiers, each with a different height between 1 and n, inclusive.  Using this information, you must  the lineup from that morning. You are given a int[] left, the ith element of which represents the number of taller soldiers to the left of the soldier with height i (where i is a 1-based index).  Return a int[] containing the heights of the soldiers from left to right in the lineup.  The input is guaranteed to produce a valid and unique output.", "pruebas": ["{2, 1, 1, 0 }", "Returns: {4, 2, 1, 3 }", "{0, 0, 0, 0, 0 }", "Returns: {1, 2, 3, 4, 5 }", "{5, 4, 3, 2, 1, 0 }", "Returns: {6, 5, 4, 3, 2, 1 }", "{6, 1, 1, 1, 2, 0, 0 }", "Returns: {6, 2, 3, 4, 7, 5, 1 }"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6631"},
{"titulo": "InboxCleanup", "categoria": "Greedy,SimpleSearch,Iteration", "dificultad": "Facil", "enunciado": "When returning from vacation, you have to delete some unwanted email messages in your inbox, like spam or other unimportant messages.  Your inbox consists of several pages that each contain the same number of messages (except possibly the last page).  Each message has two corresponding buttons that allow you to:   - add the message to the current selection  - remove the message from the current selection   In addition, each page has three buttons with the following functions:    - select all messages on the current page  - delete all selected messages on the current page  - advance to the next page of messages (unless you're already on the last page)   Selections do not extend across pages, and advancing to the next page deselects everything that is currently selected.  Also, deleting messages will not cause later messages in the inbox to scroll up to the current page.    For example if you have four email messages on one page and you would like to delete the second one, you could select it and then click on delete for a total of two clicks.  An alternative is to select all messages, then deselect all other messages except the second, and then click delete, for a total of five clicks.    Naturally, you would like to clean up your inbox with as few clicks as possible. Furthermore, you are allowed to choose the number of emails to display per page.  If you decide to display K messages per page, the first K messages will be on the first page, the next K messages will be on the second one, and so on.  Obviously, the last page might contain less than K messages.  Note that you need to check all pages of messages, even if they do not contain any messages that must be deleted.   You will be given a String messages containing a description of email messages in the order they appear in your inbox.  The 'D' character denotes a message that should be deleted, while a '.' character denotes an email that should be kept.  You will also be given two ints, low and high, denoting the inclusive lower and upper bounds of the number of messages on each page.  You should choose how many emails to display per page such that the number of clicks needed is minimal, and then return the number of clicks.  ", "pruebas": ["\"..........\"", "5", "10", "Returns: 0", "\".D.D.DD.D.\"", "5", "5", "Returns: 8", "\"...D..DDDDDD...D.DD..\"", "3", "10", "Returns: 12", "\"D.D..D..DD.DDDD.D.DDD.DDDD..\"", "3", "11", "Returns: 17", "\"DDD.........................\"", "1", "3", "Returns: 11"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6619"},
{"titulo": "GroupWork", "categoria": "Greedy,Sorting", "dificultad": "Facil", "enunciado": " You have many people working for you, and you have an urgent job that needs to be done immediately.  You know each worker's skill level at performing the task, and you also know that groups often work better than individuals.  This particular task requires everybody in a group to perform at the same pace.  Therefore, a group of talented people can easily be slowed down by having a single less talented member.  You have established that the productivity of a group is K*X, where K is the number of people in the group and X is the minimum skill level in the group.  You must assemble a group with the highest possible productivity.  You will be given two int[]s p and s describing the people who work for you.  Each element of p represents a set of workers who all have the same skill level.  The i element of p is the number of people in the i set, and the i element of s is the skill level of each worker in the i set.  The input is organized into sets only for convenience.  You are free to choose any number of individuals from any number of sets when assembling your group. See examples for further clarification. Return the highest achievable productivity. ", "pruebas": ["{1,2,1}", "{3,5,9}", "Returns: 15", "\nGroup | Productivity   Group | Productivity    Group | Productivity\n------+-------------   ------+-------------  --------+-------------\n  3   | 3               3-9  |  6             3-5-9  | 9\n  5   | 5               5-5  | 10             5-5-9  | 15\n  9   | 9               5-9  | 10            3-5-5-9 | 12\n 3-5  | 6              3-5-5 |  9\n", "{2,2,2,2}", "{5,1,1,5}", "Returns: 20", "{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}", "{31,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}", "Returns: 31", "{1000000000,1000000000,1000000000}", "{1000,999,998}", "Returns: 2994000000000"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6804"},
{"titulo": "RoadsAndFools", "categoria": "Greedy,SimpleSearch,Iteration", "dificultad": "Facil", "enunciado": "In one big country there is a saying that \"we've got only two troubles: roads and fools\". This problem is about both of them. Two cities of this country are connected by a highway. Some points on the highway are marked with milestones. On the two sides of each milestone the distances to the two cities are written. When you travel from one city to another, the milestones show the distance traveled from the origin city. If the milestones are placed correctly, the numbers you see while traveling must go in ascending order since the distance you've traveled is always increasing. During the reconstruction of the highway, some of the milestones were stolen, some were broken and some... just disappeared. On top of it all a group of bandits with unexplained motives set out to the highway one night and reversed some of the milestones. Given the state of the remaining milestones after the act, determine if it is possible to restore the correct orientations. You are given an int length, the length of the highway, and a int[] frontSides. Each element of frontSides is the mark on the front side of the milestone in the order they are seen traveling from the first city to the second. The mark on the opposite side of milestone i is obviously length-frontSides[i]. Return a String containing the restored sequence of milestones separated by single spaces (again, as seen traveling from the first city to the second). If there is more than one solution, return \"MULTIPLE SOLUTIONS\". If no solution exists (you can never tell what else could have happend to the milestones in that big country...), return \"NO SOLUTION\". Two solutions are considered equal if you see the same numbers on all milestones when traveling between the cities (see examples 4 and 5 for further clarification).", "pruebas": ["5", "{1, 2, 3}", "Returns: \"1 2 3\"", "5", "{5, 2, 0}", "Returns: \"MULTIPLE SOLUTIONS\"", "5", "{4, 4}", "Returns: \"1 4\"", "5", "{4, 4, 4}", "Returns: \"NO SOLUTION\"", "5", "{3}", "Returns: \"MULTIPLE SOLUTIONS\"", "10", "{5}", "Returns: \"5\""], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=6674"},
{"titulo": "CreatePairs", "categoria": "Greedy,SimpleMath,Sorting", "dificultad": "Facil", "enunciado": " You are given a list of integers, and you are allowed to group elements into pairs.  Each element must either belong to a single pair or remain unpaired.  Sum the products of the pairs with the values of the unpaired elements.  Your goal is to maximize this sum.   For example, consider the list {0, 1, 2, 4, 3, 5}.  If you make the pairs (2, 3) and (4, 5), the sum is 0 + 1 + (2 * 3) + (4 * 5) = 27.   You are given a int[] data containing the list of integers.  Return the maximum possible sum.  ", "pruebas": ["{0, 1, 2, 4, 3, 5}", "Returns: 27", "{-1, 1, 2, 3}", "Returns: 6", "{-1}", "Returns: -1", "{-1, 0, 1}", "Returns: 1", "{1, 1}", "Returns: 2"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=7309"},
{"titulo": "LostParentheses", "categoria": "Greedy", "dificultad": "Facil", "enunciado": " We have an arithmetic expression made up of positive integers, the + and - operators and parentheses. All the parentheses, however, have been erased by the cleaning staff and we want to calculate the minimum value the original expression may have had.  You will be given a String e containing the expression without the parentheses. Return the minimum value the original expression could have had before the parentheses were erased. ", "pruebas": ["\"55-50+40\"", "Returns: -35", "\"10+20+30+40\"", "Returns: 100", "\"00009-00009\"", "Returns: 0"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=7754"},
{"titulo": "MaximizeSquares", "categoria": "Geometry,Greedy,Math", "dificultad": "Facil", "enunciado": "Consider an arrangement of N points on the cartesian plane. The \"square count\" of the points is the total number of distinct squares with sides parallel to the coordinate axes which can be built using 4 different points as vertices.  Your task is to return the maximum square count, considering all possible arrangements of N points on the plane.", "pruebas": ["4", "Returns: 1", "5", "Returns: 1", "6", "Returns: 2", "16", "Returns: 14", "115", "Returns: 340"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=7735"},
{"titulo": "ObtainingDigitK", "categoria": "Greedy", "dificultad": "Facil", "enunciado": " Return the smallest non-negative integer that can be added to originalNumber such that the resulting integer contains at least one digit k. All numbers should have no extra leading zeroes.  ", "pruebas": ["\"153\"", "7", "Returns: 4", "\"158\"", "7", "Returns: 9", "\"7853192\"", "2", "Returns: 0", "\"99999999999999999999999999999999999999999999999\"", "0", "Returns: 1"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8181"},
{"titulo": "LameKnight", "categoria": "Greedy", "dificultad": "Facil", "enunciado": " A lame knight is located at the bottom-left corner of a height x width chessboard.  Unlike a healthy knight, a lame knight can only make moves where he goes to the right.  The only possible moves are:    The knight will make one trip, and he wants to maximize the number of visited cells.  The knight's starting cell counts toward this number. There is also one restriction for the knight's trip: it must contain each kind of a move at least once, unless it is shorter than 4 moves. If the knight makes less than 4 moves (thus visiting less than 5 cells), his moves are not limited in any way. Return the maximal number of cells the knight can visit during one trip, including the initial cell.  ", "pruebas": ["100", "50", "Returns: 48", "1", "1", "Returns: 1", "17", "5", "Returns: 4", "2", "4", "Returns: 2", "20", "4", "Returns: 4"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8183"},
{"titulo": "UnderscoreJustification", "categoria": "Greedy,StringManipulation", "dificultad": "Facil", "enunciado": "Most word processors available today allow several standard ways to format lines in a paragraph.  One of those ways is to 'justify' each line to a given width.  The precise definition for that operation is as follows: Assume that a line of text consists of several words separated by spaces (for simplicity, there will be no punctuation).  Define a gap as the sequence of spaces between a pair of adjacent words.  When reformatting a line, each gap can be replaced with a gap of a different non-zero length.  The line is said to be justified to width w if it is exactly w characters long, has no leading or trailing spaces, and all gaps are as evenly distributed as possible.  This means that the gaps should all be of equal length, or, if that is not possible, the difference in length between the longest and smallest gaps must be 1. To better illustrate the results of the justification operation, we will use underscores ('_') in place of spaces. Obviously, the above rules don't uniquely define the result of a justification.  If there are multiple ways to justify a line of text, the one that comes earliest lexicographically is used.  Note that an underscore comes after uppercase letters but before lowercase letters in the ASCII ordering. You are given a String[] words containing all the words in a line of text.  The words are given in the order that they appear in the line.  Return the line of text justified to the given width, using underscores as spaces. ", "pruebas": ["{\"A\", \"quick\", \"brown\", \"fox\", \"jumps\", \"over\", \"the\", \"lazy\", \"dog\"}", "50", "Returns: \"A___quick__brown__fox__jumps__over__the__lazy__dog\"", "{\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\"}", "32", "Returns: \"Alpha_Beta_Gamma__Delta__Epsilon\"", "{\"Hello\", \"world\", \"John\", \"said\"}", "29", "Returns: \"Hello____world___John____said\""], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8482"},
{"titulo": "MarblesRegroupingEasy", "categoria": "Greedy,SimpleSearch,Iteration", "dificultad": "Facil", "enunciado": " John is a marble collector. He keeps his marbles in boxes. He also likes to keep things in order.    One day, his younger brother was playing with the marbles.  After he was done, he put all the marbles back in boxes, but he did it randomly, so certain boxes might now contain marbles of different colors. John wants him to regroup the marbles so that the grouping satisfies the following restrictions:      You are given a String[] boxes, where the j-th digit of the i-th element is the number of marbles of color j in the i-th box. Return the minimal number of moves necessary to regroup the marbles, where each move consists of taking any number of marbles from one box (not necessarily of the same color) and putting them into another. ", "pruebas": ["{\"20\",\n \"11\"}", "Returns: 0", "{\"11\",\n \"11\",\n \"10\"}", "Returns: 1", "{\"10\",\n \"10\",\n \"01\",\n \"01\"}", "Returns: 1", "{\"11\",\n \"11\",\n \"11\",\n \"10\",\n \"10\",\n \"01\"}", "Returns: 3", "{\"020008000070\",\n \"000004000000\",\n \"060000600000\",\n \"006000000362\",\n \"000720000000\",\n \"000040000000\", \n \"004009003000\",\n \"000800000000\", \n \"020030003000\",\n \"000500200000\",\n \"000000300000\"}", "Returns: 6"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8527"},
{"titulo": "RoughStrings", "categoria": "Greedy", "dificultad": "Facil", "enunciado": "Given a string s, its roughness is calculated as follows:  Let c1 be the letter that appears most frequently in s, and let c2 be the letter that appears least frequently (c2 must appear at least once).  The roughness of s is the number of occurrences of c1 minus the number of occurrences of c2.  You are allowed to modify s by erasing between 0 and n characters, inclusive (see example 1 for clarification).  Return the minimum possible roughness that can be achieved by such a modification.", "pruebas": ["\"aaaaabbc\"", "1", "Returns: 3", "\"aaaabbbbc\"", "5", "Returns: 0", "\"veryeviltestcase\"", "1", "Returns: 2", "\"gggggggooooooodddddddllllllluuuuuuuccckkk\"", "5", "Returns: 3", "\"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz\"", "17", "Returns: 0", "\"bbbccca\"", "2", "Returns: 0"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8594"},
{"titulo": "StreetWalking", "categoria": "Greedy,SimpleMath", "dificultad": "Facil", "enunciado": " You are walking home from school through the city.  The city is infinite in size, with vertical streets located at every integer X value and horizontal streets located at every Y value.  You are currently located at (0,0) and are trying to get to your home, located at (X, Y).  You have two methods of travel available to you:  you can walk along the street to proceed to a horizontally or vertically adjacent intersection (which takes walkTime seconds), or you can sneak across the block diagonally to the opposite corner (taking sneakTime seconds).  You can walk or sneak in any of the eight directions shown in the image (see example 2).      Return the least amount of time that it will take you to return home.  See the examples for clarification. ", "pruebas": ["4", "2", "3", "10", "Returns: 18", "4", "2", "3", "5", "Returns: 16", "2", "0", "12", "10", "Returns: 20", "25", "18", "7", "11", "Returns: 247", "24", "16", "12", "10", "Returns: 240", "10000000", "50000000", "800", "901", "Returns: 41010000000", "135", "122", "43", "29", "Returns: 3929"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8464"},
{"titulo": "DNAString", "categoria": "Greedy,SimpleSearch,Iteration", "dificultad": "Facil", "enunciado": "A string of length L is called periodic with period p if the i-th character is equal to the (i+p)-th character for all i between 0 and L-p-1, inclusive.  For example, the strings \"CATCATC\", \"CATCAT\", \"ACTAC\" and \"ACT\" are all periodic with period 3.  You are given a String[] dna.  Concatenate the elements of dna and return the minimum number of replacements needed to make the resulting string periodic with period less than or equal to maxPeriod.  Each replacement consists of changing a single character from one letter to any other letter.", "pruebas": ["3", "{\"ATAGATA\"}", "Returns: 1", "2", "{\"ACGTGCA\"}", "Returns: 3", "13", "{\"ACGCTGACAGATA\"}", "Returns: 0", "1", "{\"AAAATTTCCG\"}", "Returns: 6", "12", "{\"ACGTATAGCATGACA\",\"ACAGATATTATG\",\"ACAGATGTAGCAGTA\",\"ACCA\",\"GAC\"}", "Returns: 20"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8584"},
{"titulo": "OlympicCandles", "categoria": "Greedy", "dificultad": "Facil", "enunciado": " To celebrate the upcoming Thought Challenge Olympics, you are going to follow tradition and light candles.  On the first night of the event, you will light one candle.  At the end of the night, you will extinguish the candle.  On each subsequent night, you will light one more candle than you did on the previous night, so that on the n-th night (indexed from 1) you will light n candles (and extinguish them all in the morning).  Each night that you light a candle, its height will decrease by 1 inch; once its height reaches 0 inches, you cannot use it anymore.  You are given a int[] candles, the i-th element of which is the height of the i-th candle that you own.  Return the maximum number of nights you can celebrate the event without going to the store to get more candles.  For example, if you have three candles of height 2, you can light one the first night, the other two on the second night, and then all three candles on the third night. ", "pruebas": ["{2, 2, 2}", "Returns: 3", "{2, 2, 2, 4}", "Returns: 4", "{5, 2, 2, 1}", "Returns: 3", "{1, 2, 3, 4, 5, 6}", "Returns: 6", "{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}", "Returns: 4"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=8467"},
{"titulo": "OrderedSuperString", "categoria": "Greedy,StringManipulation", "dificultad": "Facil", "enunciado": "A string X is an ordered superstring of the String[] words if wordswordswords For example \"abca\" is an ordered superstring of {\"abc\", \"ca\"}, but \"cabc\" is not.   Given a String[] words, return the length of its shortest ordered superstring. ", "pruebas": ["{\"abc\",\"ca\"}", "Returns: 4", "{\"a\",\"a\",\"b\",\"a\"}", "Returns: 3", "{\"abcdef\", \"ab\",\"bc\", \"de\",\"ef\"}", "Returns: 6", "{\"ab\",\"bc\", \"de\",\"ef\",\"abcdef\"}", "Returns: 12"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=9823"},
{"titulo": "ColoringRectangle", "categoria": "Greedy,Sorting", "dificultad": "Facil", "enunciado": "NOTE: This problem statement contains images that may not display properly if viewed outside of the applet.   You are given a white rectangle of size width by height. A green horizontal line (parallel to the width of the rectangle) is drawn through the middle of the rectangle so that it divides the rectangle into two congruent rectangles. This line extends infinitely out of the rectangle. You are asked to place red and blue disks (a disk is a circle and its interior) on the rectangle so that the entire rectangle is covered. The center of every disk must be placed on the green line, not necessarily within the rectangle bounds. Disks are placed sequentially from left to right, i.e., the center of each next placed disk must lie strictly to the right of the center of the last previously placed disk. Each disk is placed on top of all previously placed disks, i.e., when a disk is placed it covers any parts of previously placed disks that overlap. To challenge yourself, you have decided to only allow disk placements that satisfy the following additional constraint.   Every point covered by a newly placed disk must either  You are given int[] red and int[] blue. The number of elements in red and blue corresponds to the number of red and blue disks you have, respectively. Each element of red or blue is the diameter of a red or blue disk, respectively. Note that each disk can only be used at most once. Find the smallest number of disks that can be placed as described above such that every point in the rectangle is covered by at least one disk. Return -1 if this is not possible.", "pruebas": ["11", "3", "{5,5}", "{2,5}", "Returns: 3", "30", "5", "{4,10,7,8,10}", "{5,6,11,7,5}", "Returns: 4", "16", "4", "{6,5,7}", "{5}", "Returns: -1", "4", "4", "{5}", "{6}", "Returns: 1", "6", "2", "{6,6}", "{2}", "Returns: 3"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=10731"},
{"titulo": "DoorsGame", "categoria": "Greedy,Simulation", "dificultad": "Facil", "enunciado": "John and Gogo are playing Doors Game. This game is played in a building containing a single row of N+1 rooms, numbered 0 through N from left to right. One of the rooms is called the trophy room. There's a door between each pair of adjacent rooms. Each door has a color, and there are 16 possible colors (represented by uppercase letters 'A' through 'P'). All doors are initially closed.   Initially, John is in room 0 and Gogo is in room N. The two players alternate turns, and John gets the first turn. On each turn, the current player chooses a color which hasn't yet been chosen from among the 16 possible colors. All doors, if any, with the chosen color are then opened. At this point, if one of the players can reach the trophy room by walking through only open doors, that player wins and the game ends. If both players can reach the trophy room, the game ends in a draw. If neither player can reach the trophy room, the game continues.   Each player will play according to the following strategy: Each time a player needs to choose a color, he will make make his choice as follows:   You are given the colors of the doors in the String doors. The i-th character in doors is the color of the door connecting rooms i and i+1. You are also given an int trophy, which denotes the number of the trophy room. If the game ends in a draw, return 0. Otherwise, let X be the number of colors chosen in the game. If John wins, return X. If Gogo wins, return -X.", "pruebas": ["\"ABCD\"", "2", "Returns: 3", "\"ABCC\"", "2", "Returns: -2", "\"ABABAB\"", "3", "Returns: 0", "\"ABAPDCAA\"", "5", "Returns: -4", "\"MOCFDCE\"", "3", "Returns: 5", "\"ABCCDE\"", "3", "Returns: 0", "\"ABCCD\"", "3", "Returns: 0"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=10915"},
{"titulo": "Badgers", "categoria": "Greedy,SimpleSearch,Iteration,Sorting", "dificultad": "Facil", "enunciado": "Badgers are lovely furry animals, and Manao has just decided to start keeping a few. The pet shop has offered him N badgers, and they are all so cute that Manao wants to take as many as he can feed. Normally, a badger needs some amount of food per day to be satisfied. However, if he sees other badgers eating, his greed awakens and he wants to eat more. A badger will want a fixed additional amount of food for each co-eater.  You're given int[]s hunger and greed, both containing N elements. The i-th element of hunger is the number of units of food that the i-th badger needs per day if he's alone. The i-th element of greed is the amount of additional units of food the i-th badger will need for each co-eater. Return the maximum number of badgers Manao can take while keeping them all satisfied if he can supply no more than totalFood units of food per day. ", "pruebas": ["{1,2,3}", "{2,2,1}", "7", "Returns: 2", "{5,2,1,5}", "{0,2,4,1}", "19", "Returns: 3", "{1,1,1,1,1}", "{1000,1000,1000,1000,1000}", "10", "Returns: 1", "{1,2,3,4,5,6,7,8,9,10}", "{10,9,8,7,6,5,4,3,2,1}", "100", "Returns: 5"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=10797"},
{"titulo": "OneRegister", "categoria": "Greedy,SimpleMath", "dificultad": "Facil", "enunciado": " You've designed a computer and implemented all the common arithmetic operators: addition, subtraction, multiplication and integer division.  However, your budget was very limited, so you could only afford to place a single register in the computer.  The register can store any non-negative integer value.  Since there is only one register, there is no need to identify the store location or the operands of each operation or its result.  The programming language has four instructions: '+', '-', '*' and '/'.  Each instruction performs the corresponding operation using the value in the register as both its parameters.  It then stores the result in the same register, overwriting the previous content.  A program for your computer is a sequential list of zero or more instructions.  You want to show that, even with its limitations, your newly constructed computer is powerful.  You will be given two ints s and t.  Return the shortest program that finishes with a value of t in the register if it contained s before executing.  If there is more than one possible answer, return the one that comes earliest lexicographically.  If there is no program that can do the job, return \":-(\" (quotes for clarity) instead. ", "pruebas": ["7", "392", "Returns: \"+*+\"", "\n Reg | Ins | Res\n-----+-----+-----\n   7 |  +  |  14\n  14 |  *  | 196\n 196 |  +  | 392\n", "7", "256", "Returns: \"/+***\"", "4", "256", "Returns: \"**\"", "7", "7", "Returns: \"\"", "7", "9", "Returns: \":-(\"", "10", "1", "Returns: \"/\""], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=10992"},
{"titulo": "TimeTravellingGardener", "categoria": "BruteForce,Geometry,Greedy", "dificultad": "Facil", "enunciado": "NOTE: This problem statement contains images that may not display properly if viewed outside of the applet.   There are N trees arranged in a straight horizontal line. They are numbered 0 through N-1 from left to right. The distance between tree i and tree (i+1) is distance[i], and the initial vertical height of tree i is height[i]. Each tree is assumed to be a perfect vertical segment.   Your goal is to make the topmost points of all the trees collinear. To do this, you can choose any number of trees and have them travel back to a time when they were shorter. You can decrease the height of each chosen tree to any non-negative value (not necessarily an integer). You will operate on each tree individually, so the trees do not all have to decrease in height by the same amount. The trees that you do not choose will all remain at their original heights.   Return the minimum number of trees you must send back in time to achieve this goal.", "pruebas": ["{2,2}", "{1,3,10}", "Returns: 1", "{3,3}", "{3,1,3}", "Returns: 2", "{1,3}", "{4,4,4}", "Returns: 0", "{4,2}", "{9,8,5}", "Returns: 1", "{476,465,260,484}", "{39,13,8,72,80}", "Returns: 3", "{173,36,668,79,26,544}", "{488,743,203,446,444,91,453}", "Returns: 5", "{2,4,2,2,4,2,4,2,2,4}", "{2,2,10,10,10,16,16,22,22,28,28}", "Returns: 6"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11060"},
{"titulo": "StonesGame", "categoria": "Greedy,SimpleMath", "dificultad": "Facil", "enunciado": "Romeo and his friend Strangelet are playing a game. There are N stones in a row, all of which are black except for the M-th one, which is white (all positions in this problem are 1-based). The players alternate turns, and Romeo plays first. On each turn, a player must choose exactly K consecutive stones, one of which must be white, and reverse their order. The  is the first player who puts the white stone in the L-th position.  Return \"Romeo\" if Romeo can win regardless of how Strangelet plays, and return \"Strangelet\" if Strangelet can win regardless of Romeo's strategy.  Otherwise, return \"Draw\" since neither player can win if both players play optimally.  All quotes are for clarity only.", "pruebas": ["3", "1", "1", "2", "Returns: \"Draw\"", "5", "1", "2", "2", "Returns: \"Romeo\"", "5", "5", "2", "3", "Returns: \"Strangelet\"", "5", "5", "2", "2", "Returns: \"Draw\"", "1000000", "804588", "705444", "292263", "Returns: \"Romeo\"", "1000000", "100000", "500000", "600000", "Returns: \"Strangelet\""], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11292"},
{"titulo": "Painting", "categoria": "Greedy,SimpleSearch,Iteration,Simulation", "dificultad": "Facil", "enunciado": "Normally Mr. Grey is not a painter, but he recently had an absolutely brilliant idea for a picture. He thinks that once drawn, it will bring him world-wide fame.  The picture will be painted on an NxM sheet of white paper consisting of 1x1 squares. Its rows are numbered from 0 to N-1 and the columns are numbered from 0 to M-1. The cell in row i, column j is denoted as (i, j).  Of course, Mr. Grey already has a picture plan in his mind. It is given in a String[] picture, which contains exactly N elements, where each element contains exactly M characters. ?haracter j in element i of picture will be 'B' if the cell (i, j) must be painted black, and it will be 'W' if this cell must be left white.  Mr. Grey has a lot of black paint, but unfortunately he doesn't have a brush, so he went to a local shop to buy one. The shop offers square brushes of different sizes. More exactly, for each positive integer S, one can buy an SxS brush in the shop. Using an SxS brush, Mr. Grey will be able to paint entirely black SxS squares on the sheet of paper. In other words, he can choose row R and column C such that 0 <= R <= N - S, 0 <= C <= M - S, and then paint all cells (r, c) such that R <= r < R + S and C <= c < C + S in black paint. He can repeat this operation infinitely many times. If a cell must be black according to picture, it may be painted black several times. However, if a cell must be white, then it must never be painted black.  It's easy to see that every picture can be drawn using a 1x1 brush, but it will be impossible to draw some pictures using larger brushes. Buying a 1x1 brush seems to be the most practical choice. However, Mr. Grey is sure that big masters must use big brushes. Therefore, he would like to buy the largest possible brush that will still allow him to draw the picture that he has in mind.  Return the maximum value of S such that it's possible to draw picture using a brush of size SxS.", "pruebas": ["{\"BBBB\",\n \"BBBB\",\n \"BBBB\",\n \"BBBB\"}", "Returns: 4", "{\"BBBB\",\n \"BWWB\",\n \"BWWB\",\n \"BBBB\"}", "Returns: 1", "{\"WBBBBB\",\n \"BBBBBB\",\n \"BBBBBB\",\n \"BBBBBB\"}\n", "Returns: 3", "{\"BBBB\",\n \"BBBB\",\n \"WBBB\",\n \"BBBB\",\n \"BBBB\",\n \"BBBB\"}\n", "Returns: 2", "{\"WBBBBBWWWWWWWWW\",\n \"WBBBBBBWWWWWWWW\",\n \"WBBBBBBBBBBBWWW\",\n \"WBBBBBBBBBBBWWW\",\n \"BBBBBBBBBBBBBBB\",\n \"BBBBBBBBBBBBBBB\",\n \"BBBBBBBBBBBBBBB\",\n \"BBBBBBBBWWBBBBB\",\n \"BBBBBBBBWBBBBBB\",\n \"WBBBBBBBWBBBBBW\",\n \"BBBBBBBWWBBBBBW\",\n \"BBBBBBBWWBBBBBW\",\n \"BBBBBBWWWBBBBBW\",\n \"BBBBBWWWWWWWWWW\",\n \"BBBBBWWWWWWWWWW\"}\n", "Returns: 5"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11310"},
{"titulo": "ColorfulCards", "categoria": "Greedy", "dificultad": "Facil", "enunciado": "Rabbit Hanako has N cards numbered 1 through N. Each card's number is written on its front side. The back side of each card is colored red if the number is prime, and blue if it is not prime.   Cat Taro has chosen a subset of these cards and arranged them face down in a row. The cards are sorted in increasing order from left to right. He wants Hanako to guess the numbers written on the cards. Hanako can only see the colored back side of each card. You are given a String colors, where the i-th character is 'R' if the i-th card from the left is red, and 'B' if it is blue.   Return a int[] containing exactly K elements, where K is the number of characters in colors. The i-th element of the return must be the number written on the i-th card if it can be uniquely determined. Otherwise, the i-th element must be -1. It is guaranteed that there exists at least one sequence that matches colors. ", "pruebas": ["5", "\"RRR\"", "Returns: {2, 3, 5 }", "7", "\"BBB\"", "Returns: {1, 4, 6 }", "6", "\"RBR\"", "Returns: {-1, 4, 5 }", "58", "\"RBRRBRBBRBRRBBRRBBBRRBBBRR\"", "Returns: \n{-1, -1, -1, -1, -1, -1, -1, -1, 17, 18, 19, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, 53 }", "495", "\"RBRRBRBBRBRRBBRRBBBRRBBBRR\"", "Returns: \n{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11302"},
{"titulo": "ColoredStrokes", "categoria": "Greedy,StringManipulation", "dificultad": "Facil", "enunciado": "Manao has a bitmap H pixels high and W pixels wide. Initially, each of the pixels is white. Manao draws several (possibly zero) horizontal and/or vertical strokes. A stroke is a line segment 1 pixel thick and 1 or more pixels long. Manao only draws horizontal strokes with red color and vertical strokes with blue. He can paint a one pixel long stroke with either red or blue color, and the stroke will be considered horizontal if red and vertical if blue. Manao never draws two horizontal or two vertical strokes that overlap. If a horizontal stroke and a vertical stroke cross, the pixel at their intersection becomes green.  You're given a String[] picture denoting the bitmap after Manao's drawing experiments. The x-th character of the y-th element of picture describes the color of the pixel at coordinates (x, y) of the bitmap, where (0, 0) is the pixel at the top left corner and (W-1, H-1) is the pixel at the bottom right corner.  'R' is red, 'G' is green, 'B' is blue and '.' is white. Return the least possible number of strokes needed to obtain the given picture.", "pruebas": ["{\"...\",\n \"...\"}", "Returns: 0", "{\"..B.\",\n \"..B.\"}", "Returns: 1", "{\".BB.\"}", "Returns: 2", "{\"...B..\",\n \".BRGRR\",\n \".B.B..\"}", "Returns: 3", "{\"...B..\",\n \".BRBRR\",\n \".B.B..\"}", "Returns: 4", "{\"GR\",\n \"BG\"}", "Returns: 4"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11306"},
{"titulo": "PermutationSignature", "categoria": "Greedy,SimpleMath", "dificultad": "Facil", "enunciado": " The signature of a permutation is a string that is computed as follows: for each pair of consecutive elements of the permutation, write down the letter '' (increasing) if the second element is greater than the first one, otherwise write down the letter '' (decreasing).    For example, the signature of the permutation {3,1,2,7,4,6,5} is \"\".    Your task is to reverse this computation: You are given a String signature containing the signature of a permutation. Find and return the lexicographically smallest permutation with the given signature. If no such permutation exists, return an empty int[] instead. ", "pruebas": ["\"IIIII\"", "Returns: {1, 2, 3, 4, 5, 6 }", "\"DI\"", "Returns: {2, 1, 3 }", "\"IIIID\"", "Returns: {1, 2, 3, 4, 6, 5 }", "\"DIIDID\"", "Returns: {2, 1, 3, 5, 4, 7, 6 }"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11115"},
{"titulo": "MafiaGame", "categoria": "Greedy,Simulation", "dificultad": "Facil", "enunciado": "N friends (numbered from 0 to N-1) play a game called Mafia. The exact rules of the game are not important for this problem. What's important is that at some point in the game they will need to choose one player who will lose and leave the game.  It is known that some players have a definite opinion on who should lose. Their opinions are given in the int[] decisions, where each element corresponds to a single opinion and is the number of a player who should lose according to that opinion. All opinions in decisions belong to different players. If decisions contains less than N elements, then all other players do not have a definite opinion on who should lose.  In order to determine who will lose, one or more rounds of voting will be conducted. In each round, there's a set of players for whom the players are allowed to vote. The players in this set are called \"vulnerable\". It's impossible to vote for players not in this set. Before the first round of voting, all N players are included in this set.  All N players will vote in each round. The voting is held according to the following scheme:  If it is possible that an infinite number of voting rounds will be held, then return 0. Otherwise, consider an array containing exactly N elements, where the i-th element (0-based) is equal to the probability that the i-th player will lose. Return the maximum value among all elements of this array.", "pruebas": ["3", "{1, 1, 1}", "Returns: 1.0", "5", "{1, 2, 3}", "Returns: 0.0", "20", "{1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 18, 19, 0}", "Returns: 0.0", "23", "{17, 10, 3, 14, 22, 5, 11, 10, 22, 3, 14, 5, 11, 17}", "Returns: 0.14285714285714285"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11342"},
{"titulo": "FoxPlayingGame", "categoria": "DynamicProgramming,Greedy,SimpleMath", "dificultad": "Facil", "enunciado": "Fox Ciel was very bored, so she invented a single player game. The rules of the game are:  You start with 0 points. You make exactly nA+nB moves. You have two types of moves available. These are called move A and move B. Exactly nA times you will make move A. Exactly nB times you will make move B. The moves can be in any order. The moves affect your score in the following ways:   You are given int nA, int nB, int paramA and int paramB.  Calculate scoreA and scoreB as follows (\"/\" denotes exact division, without any rounding): paramAparamB Return the maximum possible score after nA+nB moves.", "pruebas": ["scoreA = ", "/1000.0\nscoreB = ", "/1000.0", "5", "4", "3000", "2000", "Returns: 240.0", "3", "3", "2000", "100", "Returns: 6.0", "4", "3", "-2000", "2000", "Returns: -8.0", "5", "5", "2000", "-2000", "Returns: 160.0", "50", "50", "10000", "2000", "Returns: 5.62949953421312E17", "41", "34", "9876", "-1234", "Returns: 515323.9982341775"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11284"},
{"titulo": "ToastXToast", "categoria": "Greedy", "dificultad": "Facil", "enunciado": "NOTE: This problem statement contains images that may not display properly if viewed outside of the applet.   Toastman is going to create several eye-popping slices of toast out of several types of bread.     Each type of bread has a positive number X (not necessarily integer) such that if a slice of bread of that type is toasted for less than X minutes, it becomes under toasted and if it is toasted for more than X minutes, it becomes over toasted. A slice of bread that is toasted for exactly X minutes becomes an eye-popping slice of toast.      Note that the number X for different types of bread may be different, but such numbers will be the same for every slice of bread of a particular bread type.    Toastman has toasted several slices of bread with the hope of creating an eye-popping slice of toast from several types of bread. Unfortunately he didn't know the exact value of X for any type of bread so all the slices of bread that he toasted became either under toasted or over toasted. You are given int[]s undertoasted and overtoasted denoting the slices of toast that were under toasted and over toasted, respectively. Each element will be an integer denoting the number of minutes that the corresponding slice of bread was toasted.    Toastman does not have a very good memory (his brain is made out of bread!). Although he forgot which type of bread was used for each slice of toast, he thinks that the following condition was satisfied:  Return the minumum number of types of bread that could statisfy this condition. If the condition can not be satisified return -1.", "pruebas": ["{2,4}", "{5,6,3}", "Returns: 2", "{5}", "{4}", "Returns: -1", "{1,2,3}", "{5,6,7}", "Returns: 1", "{1,3,5}", "{2,4,6}", "Returns: 2"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11204"},
{"titulo": "SlimeXSlimesCity", "categoria": "Greedy", "dificultad": "Facil", "enunciado": "NOTE: This problem statement contains images that may not display properly if viewed outside of the applet.   You are playing a game titled Slimes City. You are managing several towns in this game.   You have N towns in a region. For simplicity, they are named 0 through N-1. The population of town i is population[i].   You are going to  these towns to form one big city. The procedure is as follows. While the number of towns is more than one, pick two different towns, i and j. Delete these two towns and form a new one, with a population equal to the sum of the populations of towns i and j. The name of the newly formed town will be i if i had a larger population than j, or j if j had a larger population than i. If both of the original towns had the same population, either name can be chosen.   When this process ends, one town remains. That town's name becomes the city's name. Return the number of different possible names for the resulting city.", "pruebas": ["{2, 3, 4}", "Returns: 2", "{1, 2, 3}", "Returns: 2", "{8,2,3,8}", "Returns: 2", "{1000000000, 999999999, 999999998, 999999997}", "Returns: 3", "{1,1,1}", "Returns: 3", "{1, 2, 4, 6, 14, 16, 20}", "Returns: 3"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11154"},
{"titulo": "Cut", "categoria": "Greedy,Simulation", "dificultad": "Facil", "enunciado": "Fox Ciel wants to eat eels as a celebration of this year's end.  Initially, Ciel has some eels of various lengths. She only likes to eat eels of length exactly 10, no more, no less. Before she eats, she may cut the eels to prepare pieces of desired length. However, she only has the time to make at most maxCuts cuts. A single cut looks as follows:   You are given a int[] eelLengths. Each element of eelLengths is the length of one of the eels Ciel has at the beginning. You are also given the int maxCuts. Return the maximum number of eels of length exactly 10 she can produce.", "pruebas": ["{13, 20, 13}", "2", "Returns: 3", "{5, 5, 5, 5}", "2", "Returns: 0", "{34, 10, 48}", "4", "Returns: 5", "{30, 50, 30, 50}", "350", "Returns: 16"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11564"},
{"titulo": "GogoXCake", "categoria": "Greedy,Simulation", "dificultad": "Facil", "enunciado": "Like all other software engineers, Gogo likes to cut and eat cake. He used a rectangular baking dish to make a cake. The dish is divided into a grid of unit square cells. Initially, all the cells contained the cake.  Gogo's friend John wanted to eat the cake. Gogo gave John a rectangular cake cutter with the following properties: usedignored When used, the cake cutter must be placed on the dish according to the following rules: used  When the cake cutter is used in the way described above, it removes the cake from all the used cells. John may have used the cake cutter multiple times, one after another.  After John went home, Gogo examined the cake that remained in the dish. He now wants to check whether John really cut the cake according to the above rules. You are given String[]s cake and cutter. The remaining cake is described by cake. More precisely, cake[i][j] is 'X' if the cell in the i-th row and j-th column of the dish still contains cake; otherwise cake[i][j] is '.' (a period). The cake cutter is described by cutter. More precisely, cutter[i][j] is '.' (a period) if the cell in the i-th row and j-th column of the cutter is used, and 'X' if the cell is ignored.  Return \"YES\" (quotes for clarity) if it is possible that John only ate the cake by using the cutter in the way described above. Return \"NO\" otherwise.", "pruebas": ["{\"X.X\"\n,\"...\"\n,\"...\"\n,\"X.X\"}", "{\".X\"\n,\"..\"\n,\"X.\"}", "Returns: \"YES\"", "{\"..XX\"\n,\"...X\"\n,\"X...\"\n,\"XX..\"}", "{\"..\"\n,\"..\"}", "Returns: \"NO\"", "{\"...X...\"}", "{\"...\"}", "Returns: \"YES\"", "{\".X.\"\n,\"X.X\"\n,\".X.\"}", "{\".\"}", "Returns: \"YES\"", "{\"XXXXXXX\"\n,\"X.....X\"\n,\"X.....X\"\n,\"X.....X\"\n,\"XXXXXXX\"}", "{\".X.\"\n,\"XXX\"\n,\".X.\"}", "Returns: \"NO\"", "{\"..\"\n,\"X.\"\n,\".X\"}", "{\"..\"\n,\".X\"\n,\"X.\"}", "Returns: \"NO\"", "{\"X..\"\n,\".XX\"\n,\".XX\"}", "{\".XX\"\n,\".XX\"\n,\"X..\"}", "Returns: \"NO\""], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11274"},
{"titulo": "DengklekMakingChains", "categoria": "Greedy", "dificultad": "Facil", "enunciado": "Mr. Dengklek lives in the Kingdom of Ducks, where humans and ducks live together in peace and harmony.     Mr. Dengklek works as a chain maker. Today, he would like to make a beautiful chain as a decoration for one of his lovely ducks. He will produce the chain from leftovers he found in his workshop. Each of the leftovers is a chain piece consisting of exactly 3 links. Each link is either clean or rusty. Different clean links may have different degrees of beauty.    You are given a String[] chains describing the leftovers. Each element of chains is a 3-character String describing one of the chain pieces. A rusty link is represented by a period ('.'), whereas a clean link is represented by a digit ('0'-'9'). The value of the digit in the clean link is the beauty of the link. For example, chains = {\".15\", \"7..\", \"532\", \"..3\"} means that Mr. Dengklek has 4 chain pieces, and only one of these (\"532\") has no rusty links.    All links have the same shape, which allows Mr. Dengklek to concatenate any two chain pieces. However, the link shape is not symmetric, therefore he may not reverse the chain pieces. E.g., in the above example he is able to produce the chain \"532.15\" or the chain \".15..37..\", but he cannot produce \"5323..\".    To produce the chain, Mr. Dengklek will follow these steps:  The beauty of the new chain is the total beauty of all the links picked in the second step. Of course, Mr. Dengklek would like to create the most beautiful chain possible.    Return the largest possible beauty a chain can have according to the above rules.", "pruebas": ["{\".15\", \"7..\", \"402\", \"..3\"}", "Returns: 19", "{\"..1\", \"7..\", \"567\", \"24.\", \"8..\", \"234\"}", "Returns: 36", "{\"...\", \"...\"}", "Returns: 0", "{\"16.\", \"9.8\", \".24\", \"52.\", \"3.1\", \"532\", \"4.4\", \"111\"}", "Returns: 28", "{\"..1\", \"3..\", \"2..\", \".7.\"}", "Returns: 7", "{\"412\", \"..7\", \".58\", \"7.8\", \"32.\", \"6..\", \"351\", \"3.9\", \"985\", \"...\", \".46\"}", "Returns: 58"], "url": "https://community.topcoder.com/stat?c=problem_statement&pm=11754"}
]