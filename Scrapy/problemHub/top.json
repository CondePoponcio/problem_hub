[
{"titulo": "CubeTower", "categoria": "Greedy,SimpleMath", "dificultad": "-2", "enunciado": "Problem Statement Xenia and Yvona have a new toy: a collection of wooden cubes. Each cube has a positive integer side length. They have a large enough supply of cubes of all possible sizes.   Both girls have decided to use exactly N cubes, placed on top of each other, to build a tower that would have height exactly H.   Calculate and return the largest possible positive difference between the volumes of their two towers. DefinitionClass:CubeTowerMethod:differenceParameters:int, intReturns:longMethod signature:long difference(int H, int N)(be sure your method is public)", "pruebas": ["4", "2", "Returns: 12", "17", "16", "Returns: 0", "5", "3", "Returns: 12", "9", "3", "Returns: 264"]},
{"titulo": "CostMaximizer", "categoria": "Encryption/Compression,GraphTheory,Greedy", "dificultad": "3-", "enunciado": "Problem Statement You are given 2*N nodes. For each i (1 <= i <= N) there is a red node number i and a blue node number i.   Each pair of nodes is connected by an edge. For nodes i and j of the same colour this edge has weight wt(i,j). For nodes i and j of the opposite colour this edge has weight K - wt(i,j).   The value K is the same for all pairs i, j. For each edge, the value K will satisfy the following: wt(i,j) <= K <= 2*wt(i,j).    You must select exactly N out of these nodes: for each number either the red node or the blue node, but not both. Among those, you must select at least one red node and at least one blue node.   Determine and return the largest possible sum of weights in the complete graph formed by the nodes you selected and all edges between them.    You are given the ints N and K mentioned above and a int[] w with the upper triangle of the weights matrix.   You can reconstruct the whole matrix as follows:  DefinitionClass:CostMaximizerMethod:maxPossibleParameters:int, int, int[]Returns:longMethod signature:long maxPossible(int N, int K, int[] w)(be sure your method is public)", "pruebas": ["\n\nint k = 0;\nfor (int i=1; i<=N; ++i) for (int j=i+1; j<=N; ++j) {\n    wt(i,j) = wt(j,i) = w[k];\n    ++k;\n}\n", "5", "20", "{13, 15, 10, 14, 12, 12, 12, 18, 20, 13}", "Returns: 121", "5", "500433", "{401130, 423791, 344538, 499549, 328579, 480488, 456447, 479666, 368601, 250822}", "Returns: 2924315"]},
{"titulo": "Pancakes", "categoria": "Greedy,SimpleMath", "dificultad": "2-", "enunciado": "Problem Statement You have a stove and P pancake pans. The stove has enough heaters to use all pans at the same time.   You want to make N pancakes. Each pancake must be cooked for exactly two minutes: one minute from one side and then one minute from the other side.    We will measure the time in minutes since you start cooking. During each minute, each pan must either be unused or it must contain one of the pancakes. If a pan contains a pancake, the bottom side of the pancake is being cooked.   We will assume that at the beginning/end of each minute you can instantly perform all the necessary actions: getting some pancakes into pans, taking some pancakes out of pans, and flipping some pancakes over (either in the same pan or into a different pan).    Produce one possible schedule to cook all N pancakes in as few minutes as possible. Return the schedule as a String[]. Each element should describe one minute. Each element should have P characters: one for each pan. Use the character '-' to denote an empty pan. Use the first N English letters to describe the pancakes: the uppercase letter is one side being cooked and the corresponding lowercase letter the other side of the same pancake. (See the examples.)   Any valid cooking schedule that minimizes the number of minutes needed will be accepted. DefinitionClass:PancakesMethod:makePancakesParameters:int, intReturns:String[]Method signature:String[] makePancakes(int N, int P)(be sure your method is public)", "pruebas": ["1", "3", "Returns: {\"A--\", \"-a-\" }", "3", "1", "Returns: {\"A\", \"c\", \"B\", \"C\", \"a\", \"b\" }", "5", "4", "Returns: {\"bA-e\", \"ECad\", \"-BcD\" }"]},
{"titulo": "MarblePicking", "categoria": "Greedy,Sorting", "dificultad": "2-", "enunciado": "Problem StatementYou have a large collection of marbles, given in String[] marbles, where each character of each element represents the color of a particular marble in your collection.  You are planning to select count marbles from your collection.  Return the minimum number of different colors that will be present in your selection.  DefinitionClass:MarblePickingMethod:fewestColorsParameters:String[], intReturns:intMethod signature:int fewestColors(String[] marbles, int count)(be sure your method is public)", "pruebas": ["{\"AABBCC\"}", "3", "Returns: 2", "{\"ABC\",\"ABC\"}", "2", "Returns: 1", "{\"AAABBBCCCDDDDE\"}", "4", "Returns: 1", "{\"ABCDEABCDABCABA\"}", "10", "Returns: 3"]},
{"titulo": "EllysBalancedStrings", "categoria": "Greedy", "dificultad": "1-", "enunciado": "Problem Statement In the English alphabet the letters {'A', 'E', 'I', 'O', 'U'} are called vowels while all others are called consonants. Note that in this problem 'Y' is always a consonant.   A string is balanced if the number of vowels in the string is the same as the number of consonants in the string.   For example, the string \"BANANA\" is balanced: it has three consonants ('B' and two 'N') and three vowels (three 'A'). The string \"TOPCODER\" is not balanced: it has five consonants but only three vowels.    Elly has a String S. The length of S is even.   The girl can alter her string as many times as she likes. In each operation she chooses one valid index i and either increments or decrements the letter S[i].   Incrementing a letter changes it to the next letter in the alphabet (e.g., 'A' to 'B', 'L' to 'M', and 'Y' to 'Z'). Decrementing a letter changes it to the previous letter in the alphabet (e.g., 'B' to 'A', 'M' to 'L', and 'Z' to 'Y'). The letter 'A' cannot be decremented and the letter 'Z' cannot be incremented.   Multiple operations may be applied to the same index. Thus, S can be transformed into any other string of the same length.    Elly wonders what is the minimal number of operations she has to do on S in order to make it balanced. Find and return that number.  DefinitionClass:EllysBalancedStringsMethod:getMinParameters:StringReturns:intMethod signature:int getMin(String S)(be sure your method is public)", "pruebas": ["\"TOPCODER\"", "Returns: 1", "\"BANANA\"", "Returns: 0", "\"WITHOUTITIAMJUSTESPR\"", "Returns: 2", "\"NOZAPHODJUSTVERYVERYIMPROBABLE\"", "Returns: 5", "\"SYZYGY\"", "Returns: 8", "\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"", "Returns: 8"]},
{"titulo": "DivideThePlane", "categoria": "Greedy,SimpleMath", "dificultad": "1-", "enunciado": "Problem Statement You have a two-dimensional plane. You have already drawn some lines onto the plane: exactly H distinct horizontal lines and exactly V distinct vertical lines.   The lines can be seen as region boundaries. You want to divide your plane into at least N regions. If necessary, you can draw additional straight lines. Each of the new lines must also be either horizontal or vertical.   Compute and return the minimum number of additional lines you need. DefinitionClass:DivideThePlaneMethod:makeCutsParameters:int, int, longReturns:longMethod signature:long makeCuts(int H, int V, long N)(be sure your method is public)", "pruebas": ["0", "0", "1", "Returns: 0", "0", "0", "3", "Returns: 2", "4", "0", "3", "Returns: 0", "4", "0", "20", "Returns: 3", "\n    |  |  |\n    |  |  |\n----+--+--+----\n    |  |  |\n----+--+--+----\n    |  |  |\n----+--+--+----\n    |  |  |\n----+--+--+----\n    |  |  |\n    |  |  |\n", "\n    |  |  |\n   1| 2| 3| 4\n----+--+--+----\n   5| 6| 7| 8\n----+--+--+----\n   9|10|11|12\n----+--+--+----\n  13|14|15|16\n----+--+--+----\n  17|18|19|20\n    |  |  |\n", "1", "3", "35", "Returns: 6", "99999", "99997", "10000000000", "Returns: 2", "4", "7", "12345", "Returns: 210"]},
{"titulo": "QuadraticJumping", "categoria": "DynamicProgramming,GraphTheory,Greedy,Math", "dificultad": "3-", "enunciado": "Problem Statement You are on a straight line that is infinite in both directions. Your starting location is coordinate 0 and your goal is to reach coordinate goal using as few jumps as possible.   Your jumps are numbered starting from 1. The length of jump x must be exactly x^2 (x squared). For each jump you get to choose the direction in which you jump (left or right).   Return the smallest number of jumps needed to reach the given goal, or -1 if the goal cannot be reached. DefinitionClass:QuadraticJumpingMethod:jumpParameters:longReturns:longMethod signature:long jump(long goal)(be sure your method is public)", "pruebas": ["14", "Returns: 3", "28", "Returns: 4", "7", "Returns: 6", "333383335000", "Returns: 10000"]},
{"titulo": "CoolPairs", "categoria": "DynamicProgramming,Greedy", "dificultad": "3-", "enunciado": "Problem StatementTime limit is 2.5 seconds. There is a group of N people. The people are numbered from 0 to N-1. Each person in the group has a first name and a last name.  If a and b are two different people such that the last name of person a is the same as the first name of person b, the ordered pair (a, b) is called cool. Each ordered pair of people has some weight. The weight of (a, b) is weight[a*N+b]. Given a group of people, Kaede's happiness is equal to the total weight of all cool pairs in that group.   You are given the String[]s firstname and lastname. These contain the first and last names of people in the group. However, some of these names may have been replaced by wildcards (\"*\").  The total number of wildcards does not exceed 17.   Kaede plans to replace each wildcard by some non-empty string of lowercase English letters. Different wildcards may be replaced by different strings.   She wants to do this in a way that will maximize her happiness. If there are multiple optimal solutions, she prefers the lexicographically smallest one among them, as defined below.    An assignment is the sequence of strings {F[0], L[0], F[1], L[1], ..., F[N-1], L[N-1]}, where F[i] and L[i] are the names assigned to person i. (F is obtained from firstname and L from lastname by replacing each wildcard.)   Given two distinct assignments, the lexicographically smaller one is the one that has a lexicographically smaller string at the smallest index at which the two assignments differ.    Return the lexicographically smallest among all assignments that maximize Kaede's happiness. DefinitionClass:CoolPairsMethod:smallestParameters:String[], String[], int[]Returns:String[]Method signature:String[] smallest(String[] firstname, String[] lastname, int[] weight)(be sure your method is public)", "pruebas": ["{\"*\", \"john\"}", "{\"*\", \"smith\"}", "{\n-1, 1, \n1, -1\n}", "Returns: {\"smith\", \"john\", \"john\", \"smith\" }", "{\"*\", \"john\"}", "{\"*\", \"smith\"}", "{\n-1, 0,\n0, -1\n}", "Returns: {\"a\", \"a\", \"john\", \"smith\" }", "{\"*\", \"bob\", \"*\", \"alice\", \"tom\"}", "{\"bob\", \"*\", \"david\", \"*\", \"*\"}", "{\n-1, 1943, 0, 39, 2494,\n0, -1, 2934, 0, 0,\n3848, 9394, -1, 341, 2239,\n9394, 39, 0, -1, 929,\n2, 230, 0, 234, -1\n}\n", "Returns: {\"david\", \"bob\", \"bob\", \"a\", \"a\", \"david\", \"alice\", \"david\", \"tom\", \"alice\" }", "{\"e\", \"*\", \"c\", \"b\"}", "{\"*\", \"e\", \"d\", \"c\"}", "{\n-1, 2, 100, 101,\n0, -1, 0, 0,\n0, 101, -1, 0,\n0, 100, 0, -1\n}", "Returns: {\"e\", \"b\", \"d\", \"e\", \"c\", \"d\", \"b\", \"c\" }", "{\"*\",\"x\",\"*\",\"griystxs\",\"*\",\"x\",\"ikqise\",\"ikqise\",\"*\",\"zuhhj\",\"l\",\"l\",\"xhympzktz\",\"lzpbc\",\"qfqghcctv\",\"lgjmp\",\"*\",\"griystxs\",\"ikqise\",\"*\",\"ikqise\",\"*\",\"*\",\"l\",\"lgjmp\"}\n", "{\"zuhhj\",\"lzpbc\",\"ikqise\",\"*\",\"lgjmp\",\"ikqise\",\"xrp\",\"x\",\"lzpbc\",\"l\",\"xrp\",\"griystxs\",\"l\",\"*\",\"zuhhj\",\"*\",\"*\",\"*\",\"g\",\"xhympzktz\",\"*\",\"*\",\"*\",\"*\",\"xrp\"}\n", "{\n-1,0,0,0,7,0,0,0,0,0,6,0,4,0,0,0,0,0,4,0,0,0,3,0,0,\n0,-1,0,7,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,10,0,0,0,\n0,0,-1,0,0,0,0,0,0,7,6,8,0,0,0,0,0,0,0,0,10,9,0,0,0,\n0,0,0,-1,0,1,0,0,5,0,4,0,1,0,6,0,7,6,0,0,4,0,0,0,0,\n0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,5,0,0,0,\n0,0,1,0,0,-1,0,0,0,0,0,1,0,9,0,0,0,0,0,2,0,0,0,8,0,\n0,0,0,0,0,0,-1,0,0,0,0,0,0,0,0,0,0,5,0,5,0,0,0,6,0,\n0,4,0,0,0,0,0,-1,10,0,5,2,2,0,0,0,0,0,0,0,0,0,0,0,0,\n0,9,0,0,10,0,2,0,-1,0,0,0,7,10,9,0,0,8,0,0,0,7,0,0,0,\n0,0,4,10,6,0,0,0,0,-1,0,2,0,0,0,0,9,0,0,0,0,0,5,0,0,\n0,0,0,0,7,0,0,0,0,0,-1,8,0,0,2,0,0,7,0,0,0,0,0,0,2,\n0,1,0,9,0,0,0,1,8,10,5,-1,0,10,5,8,0,0,0,0,5,0,6,0,0,\n1,0,0,4,6,0,0,0,6,10,0,0,-1,0,0,0,0,0,0,10,0,10,0,0,0,\n0,0,0,6,0,0,0,0,0,0,8,0,8,-1,0,0,0,0,2,0,0,0,0,7,0,\n6,0,0,8,0,0,0,1,4,0,0,0,0,0,-1,0,5,0,3,0,0,10,0,0,0,\n0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,-1,5,10,0,0,0,0,0,0,0,\n0,0,0,0,9,5,0,0,0,0,1,2,0,0,0,0,-1,0,0,0,0,0,7,0,0,\n0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,6,0,-1,5,0,0,10,0,0,0,\n0,0,4,5,0,0,0,0,7,0,0,0,0,3,0,0,0,0,-1,0,0,0,0,0,0,\n5,0,0,0,0,0,0,3,0,8,2,10,0,1,0,0,5,0,0,-1,0,0,0,0,0,\n0,4,0,9,0,0,0,0,0,0,3,0,0,0,0,0,0,0,5,0,-1,0,0,9,0,\n0,0,0,0,0,0,0,0,0,2,0,3,0,0,0,0,0,2,0,0,0,-1,0,0,0,\n0,0,5,0,1,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,1,1,-1,0,0,\n0,0,4,9,0,0,0,0,0,0,0,0,0,3,2,0,0,0,0,0,0,4,0,-1,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0,1,0,-1\n}\n", "Returns: \n{\"zuhhj\",\n\"zuhhj\",\n\"x\",\n\"lzpbc\",\n\"l\",\n\"ikqise\",\n\"griystxs\",\n\"griystxs\",\n\"l\",\n\"lgjmp\",\n\"x\",\n\"ikqise\",\n\"ikqise\",\n\"xrp\",\n\"ikqise\",\n\"x\",\n\"griystxs\",\n\"lzpbc\",\n\"zuhhj\",\n\"l\",\n\"l\",\n\"xrp\",\n\"l\",\n\"griystxs\",\n\"xhympzktz\",\n\"l\",\n\"lzpbc\",\n\"l\",\n\"qfqghcctv\",\n\"zuhhj\",\n\"lgjmp\",\n\"griystxs\",\n\"griystxs\",\n\"l\",\n\"griystxs\",\n\"ikqise\",\n\"ikqise\",\n\"g\",\n\"l\",\n\"xhympzktz\",\n\"ikqise\",\n\"l\",\n\"ikqise\",\n\"l\",\n\"l\",\n\"l\",\n\"l\",\n\"griystxs\",\n\"lgjmp\",\n\"xrp\" }"]},
{"titulo": "CapriciousSorting", "categoria": "Greedy,SimpleMath", "dificultad": "1-", "enunciado": "Problem StatementOne day, Frederica found the int[] num that consisted of N non-negative integers. She thinks that only sorted arrays are beautiful, so she would like to transform num into a sequence that is sorted in strictly ascending order. However, she thinks that simply sorting the elements is not fun. Instead, she is going to do the following operation:  numnumnum Of course, not every selection of A makes the final sequence sorted. In order to help Frederica, please calculate and return the number of different choices for A that do change num into a sequence in strictly ascending order.DefinitionClass:CapriciousSortingMethod:countParameters:int[]Returns:intMethod signature:int count(int[] num)(be sure your method is public)", "pruebas": ["{0, 1, 2, 3, 4, 5, 6, 7}", "Returns: 134217728", "{7, 6, 5, 4, 3, 2, 1, 0}", "Returns: 134217728", "{47, 47, 42}", "Returns: 0", "{84, 94, 68, 72, 96, 31, 2, 57}", "Returns: 67108864"]},
{"titulo": "MaximumPenalty", "categoria": "Greedy,Math", "dificultad": "2-", "enunciado": "Problem Statement We have N jobs to complete. The jobs are numbered from 0 to N-1. Job i requires L[i] seconds of work. At any moment we can only work on one of the jobs.   As is usually the case, each job should be completed as soon as possible: the longer it takes, the worse the penalty will be. If job i is completed after t seconds, the penalty is calculated as follows:   penalty(i, t) = P[4i+0] * t + P[4i+1] * t + P[4i+2] * t + P[4i+3] * t   All coefficients in P are nonnegative, and therefore the penalty is nondecreasing in time.   The penalty of the whole schedule is the maximum (not the sum!) over all jobs.  Your goal is to minimize this penalty.    Clearly it doesn't pay off to jump back and forth between jobs: there is always an optimal schedule in which whenever you start working on a problem, you work on it until you complete it. Such a schedule can then be described by a list of job numbers in the order in which you should perform them. Find any such optimal schedule and return a int[] with the corresponding job order. Any optimal solution will be accepted. DefinitionClass:MaximumPenaltyMethod:scheduleParameters:int[], int[]Returns:int[]Method signature:int[] schedule(int[] L, int[] P)(be sure your method is public)", "pruebas": ["{7, 4, 1}", "{0, 0, 0, 1,\n 0, 0, 2, 0,\n 0, 3, 0, 0}", "Returns: {0, 2, 1 }", "{7, 4, 2, 5}", "{47, 0, 0, 0,\n 47, 0, 0, 0,\n 47, 0, 0, 0,\n 47, 0, 0, 0}", "Returns: {3, 2, 1, 0 }", "{7, 4, 2, 5}", "{0, 47, 0, 0,\n 0, 47, 0, 0,\n 0, 47, 0, 0,\n 0, 47, 0, 0}", "Returns: {3, 2, 1, 0 }", "{7, 4, 2, 5}", "{0, 7, 8,  15,\n 1, 6, 9,  14,\n 2, 5, 10, 13,\n 3, 4, 11, 12}", "Returns: {0, 1, 2, 3 }"]},
{"titulo": "ChristmasBatteries", "categoria": "BruteForce,DynamicProgramming,Greedy", "dificultad": "1-3", "enunciado": "Problem Statement Peter is very fond of his niece Emily. For Christmas, Peter wants to give his niece a collection of various toys. He has already purchased N toys. However, at the last moment Peter realized that he probably cannot give Emily all the toys.   The problem is that many of the toys require batteries, and those are not included in the package. Peter forgot to purchase batteries and now he could only find very few of them: he only has B batteries. And there's nothing worse than getting a toy that does not work because it lacks batteries. (Well, there are surely plenty of worse things, but not in Emily's world.)   Hence, Peter came to the following conclusion: he will only give Emily a subset of the toys he has purchased. The toys given to Emily must require at most B batteries in total.   The toys are numbered from 0 to N-1, inclusive. Toy i requires (i mod 5) batteries. The amount of fun from toy i is ((X*i*i + Y*i + Z) mod M).   The amount of fun from a collection of toys is simply the sum of amounts of fun from the individual toys in the collection. Find the collection of toys Peter should give Emily if he wants her to have as much fun as possible with the toys. Return the total amount of fun for that collection. DefinitionClass:ChristmasBatteriesMethod:mostFunParameters:int, int, int, int, int, intReturns:intMethod signature:int mostFun(int B, int N, int X, int Y, int Z, int M)(be sure your method is public)", "pruebas": ["0", "5", "1", "1", "1", "1000", "Returns: 1", "3", "5", "1", "1", "1", "1000", "Returns: 14", "3", "5", "1", "1", "1", "13", "Returns: 11", "4", "10000", "123", "456", "789", "1", "Returns: 0", "7", "4", "3", "5", "7", "997", "Returns: 100", "2", "12345", "234", "34", "5", "117", "Returns: 143371"]},
{"titulo": "BuyOneGetOneFree", "categoria": "BruteForce,Greedy,Sorting", "dificultad": "-1", "enunciado": "Problem Statement There are some items you want to purchase from a store. The prices of these items are given in the int[] prices.   You can purchase any item by paying its price.   However, the store also has a special sale today: \"buy one, get one free\". This means that whenever you bring a pair of items to the cash register, you only have to pay for the more expensive one and you'll get the other one for free as a bonus.   Given the prices, find the optimal shopping strategy and calculate the minimum you have to pay to purchase all the items you want. DefinitionClass:BuyOneGetOneFreeMethod:buyParameters:int[]Returns:intMethod signature:int buy(int[] prices)(be sure your method is public)", "pruebas": ["{47}", "Returns: 47", "{10, 20}", "Returns: 20", "{10, 20, 30, 20}", "Returns: 50", "{5, 7, 13, 2, 9}", "Returns: 22", "{100, 100, 100, 100, 100, 100}", "Returns: 300"]},
{"titulo": "DiscountedShortestPaths", "categoria": "GraphTheory,Greedy", "dificultad": "3-", "enunciado": "Problem Statement Please note the unusual time and memory limits in this problem: 4 seconds, 48 MB.   There are  n  cities numbered 0 to n-1. Some pairs of cities are connected by flights. All flights are bidirectional. The network is connected: it is possible to travel between any two cities (directly or indirectly).    You are given n and the list of flights: the int[]s a, b, c. For each valid i, there is a bidirectional flight that connects cities a[i] and b[i] and has a cost c[i] in either direction.     You have some discount coupons, each with some value. These values are given in the int[] d. For each flight you take you can only use at most one discount coupon. Also, each discount coupon can only be used once. If you have a flight with cost C and you use a discount coupon with value D, the new cost of the flight is what remains: max(0, C-D).     For each pair of cities s < t, consider the following problem: Suppose we want to travel from s to t with the given flight costs and the given discount coupons. What is the minimum total cost f(s, t) of our trip?    Calculate and return the sum of all f(s, t). DefinitionClass:DiscountedShortestPathsMethod:minimumCostSumParameters:int, int[], int[], int[], int[]Returns:longMethod signature:long minimumCostSum(int n, int[] a, int[] b, int[] c, int[] d)(be sure your method is public)", "pruebas": ["2", "{0}", "{1}", "{10}", "{5, 6}", "Returns: 4", "3", "{0, 1, 2}", "{1, 2, 0}", "{3, 3, 7}", "{2, 2, 2}", "Returns: 4", "3", "{0, 1, 2}", "{1, 2, 0}", "{3, 3, 7}", "{1, 6, 1}", "Returns: 1", "10", "{0, 1, 2, 3, 4, 5, 6, 7, 8}", "{1, 2, 3, 4, 5, 6, 7, 8, 9}", "{1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000}", "{}", "Returns: 165000000000"]},
{"titulo": "ChristmasCrackerHappiness", "categoria": "Greedy,SimpleMath,Simulation", "dificultad": "-1", "enunciado": "Problem Statement A Christmas cracker is a festive table decoration that resembles an oversized sweet-wrapper. The middle part of a cracker usually contains some small gift and a terrible Christmas pun. (\"What does Santa feel when going down a narrow chimney? Claus-trophobia!\")    It is customary that each cracker should be opened by two people. Each person takes hold of one end of the cracker and they pull in opposite directions. This will cause the cracker to split into two parts. The cracker always splits unevenly: one of the two people is the winner and gets the central chamber with the prize, the other person is the loser and gets nothing.   Whenever a cracker is opened, the winner is determined randomly. The two people opening the cracker cannot influence which one of them will be the winner.    N guests (numbered 0 to N-1) are attending your Christmas party. You already gave them M crackers (numbered 0 to M-1), and they have already opened all of them. For cracker i, guest number winner[i] was the winner and got the prize, while guest number loser[i] was the loser and got nothing.    A guest is happy if they were the winner at least once.   You would like all guests at your party to be happy. Sadly, that is not always possible: somebody may be really unlucky and lose each time they open a cracker. Thus, you would like the next best thing: at least N-1 of your guests should be happy.   You are now going to buy some additional crackers. You will then give the crackers to your guests to open. You will be handing the crackers out one at a time. For each cracker, you can select the two guests who should open it. You can then wait and see who won before you hand out the next cracker.   Remember that your goal is that at least N-1 of your guests should be happy. What is the minimum number of crackers you need to purchase so that you can reach your goal with absolute certainty? Calculate and return that number. DefinitionClass:ChristmasCrackerHappinessMethod:solveParameters:int, int[], int[]Returns:intMethod signature:int solve(int N, int[] winner, int[] loser)(be sure your method is public)", "pruebas": ["2", "{}", "{}", "Returns: 1", "5", "{0, 1, 0, 3, 2, 0, 4, 0}", "{3, 3, 4, 1, 0, 2, 1, 3}", "Returns: 0", "12", "{3, 1, 4, 1, 5, 9, 2, 6}", "{5, 3, 5, 8, 9, 7, 9, 3}", "Returns: 4"]}
]